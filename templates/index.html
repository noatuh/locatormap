<!DOCTYPE html>
<html>
<head>
  <title>Leaflet Multi-Phone Tracker with Drawing</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    #map { height: 100%; width: 100%; }
    #passwordOverlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.8); z-index: 10000;
      display: flex; justify-content: center; align-items: center;
    }
    #passwordDialog {
      background: white; padding: 30px; border-radius: 10px;
      text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      min-width: 300px;
    }
    #passwordInput {
      width: 100%; padding: 10px; margin: 15px 0;
      border: 2px solid #ddd; border-radius: 5px; font-size: 16px;
    }
    #passwordSubmit {
      background-color: #007bff; color: white; border: none;
      padding: 10px 20px; border-radius: 5px; cursor: pointer;
      font-size: 16px; width: 100%;
    }
    #passwordSubmit:hover { background-color: #0056b3; }
    #passwordError {
      color: red; margin-top: 10px; display: none;
    }
    
    /* Right sidebar for map controls */
    #controls {
      position: absolute; top: 10px; right: 10px; z-index: 1000;
      background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 8px;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      width: 250px;
    }
    #controls.hidden { opacity: 0; visibility: hidden; }
    
    /* Left sidebar for notes */
    #notesPanel {
      position: fixed; top: 0; left: 0; width: 320px; height: 100%;
      background: rgba(255, 255, 255, 0.95); z-index: 1000;
      box-shadow: 2px 0 10px rgba(0,0,0,0.1);
      display: flex; flex-direction: column;
      transition: transform 0.3s ease;
    }
    #notesPanel.hidden {
      transform: translateX(-100%);
    }
    
    #notesPanelHeader {
      background: #343a40; color: white; padding: 15px;
      font-size: 18px; font-weight: bold; text-align: center;
    }
    
    #notesPanelContent {
      flex: 1; padding: 15px; overflow: hidden;
      display: flex; flex-direction: column;
    }
    
    #notesControls {
      margin-bottom: 15px;
      display: flex; gap: 8px;
    }
    
    #notesControls button {
      flex: 1; padding: 8px 12px; border: none; border-radius: 4px;
      cursor: pointer; font-size: 14px;
    }
    
    #addNote {
      background: #28a745; color: white;
    }
    #addNote:hover {
      background: #218838;
    }
    
    #refreshNotes {
      background: #17a2b8; color: white;
    }
    #refreshNotes:hover {
      background: #138496;
    }
    
    /* Toggle buttons at bottom */
    #toggleButtons {
      position: absolute; bottom: 15px; left: 50%;
      transform: translateX(-50%); z-index: 1100;
      width: 340px; /* Wide enough to place buttons 170px from center */
      display: flex; justify-content: space-between;
      align-items: center;
    }
    
    .toggle-btn {
      padding: 10px 20px; border: none; background-color: white;
      border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      cursor: pointer; transition: all 0.3s ease;
      font-size: 14px; font-weight: 500;
      min-width: 120px;
      white-space: nowrap;
    }
    .toggle-btn:hover { 
      background-color: #f0f0f0; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      transform: translateY(-1px);
    }
    
    #toggleNotes, #toggleMenu {
      background: linear-gradient(135deg, #007bff, #6610f2);
      color: white;
    }
    #toggleNotes:hover, #toggleMenu:hover {
      background: linear-gradient(135deg, #0056b3, #520dc2);
      color: white;
    }
    .phone-label {
      background: white; padding: 10px 20px; border-radius: 4px;
      font-size: 12px; display: inline-block;
    }
    #phoneList {
      margin-top: 10px; border-top: 1px solid #ccc; padding-top: 10px;
    }
    #phoneEntries {
      max-height: 120px; overflow-y: auto; margin-bottom: 5px;
    }
    .phone-entry {
      display: flex; align-items: center; margin-bottom: 6px;
      padding: 4px; background-color: rgba(240, 240, 240, 0.5); border-radius: 4px;
    }
    .phone-entry span {
      vertical-align: middle; line-height: 1; font-size: 14px;
    }
    
    /* Add grid and POI pin styles */
    .grid-label {
      background: transparent;
      border: none;
      padding: 2px 4px;
      font-weight: bold;
      font-size: 14px;
      text-align: center;
      text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
    }
    .poi-popup .leaflet-popup-content-wrapper {
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
    }
    .poi-popup .leaflet-popup-tip {
      background-color: rgba(255, 255, 255, 0.9);
    }
    .poi-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 5px;
    }
    .poi-description {
      font-size: 12px;
      white-space: pre-wrap;
    }

    /* Notes styles */
    #notesList {
      flex: 1;
      overflow-y: auto;
      margin-top: 8px;
    }

    #noNotesMessage {
      color: #666;
      font-style: italic;
      margin: 20px 0;
      text-align: center;
    }

    .note-item {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 10px;
      font-size: 13px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .note-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-weight: bold;
      color: #495057;
    }

    .note-timestamp {
      font-size: 11px;
      color: #6c757d;
      font-weight: normal;
    }

    .note-content {
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.4;
      color: #212529;
    }

    .note-delete-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      margin-left: 8px;
    }

    .note-delete-btn:hover {
      background: #c82333;
    }

    /* Note input dialog */
    #noteDialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 25px;
      z-index: 3000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      display: none;
      min-width: 400px;
    }

    #noteDialog h3 {
      margin: 0 0 20px 0;
      color: #333;
      text-align: center;
    }

    #noteDialog textarea {
      width: 100%;
      min-height: 120px;
      margin-bottom: 15px;
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
    }

    .note-dialog-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .note-dialog-buttons button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    #saveNoteBtn {
      background: #007bff;
      color: white;
    }

    #saveNoteBtn:hover {
      background: #0056b3;
    }

    #cancelNoteBtn {
      background: #6c757d;
      color: white;
    }

    #cancelNoteBtn:hover {
      background: #545b62;
    }

    /* Compass widget styles */
    #compass {
      position: fixed;
      top: 75px;
      left: 20px;
      width: 80px;
      height: 80px;
      background: rgba(255, 255, 255, 0.95);
      border: 2px solid #333;
      border-radius: 50%;
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      font-family: Arial, sans-serif;
      font-weight: bold;
    }

    .compass-rose {
      position: relative;
      width: 60px;
      height: 60px;
    }

    .compass-direction {
      position: absolute;
      font-size: 12px;
      font-weight: bold;
      color: #333;
    }

    .compass-direction.north {
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
      color: #d32f2f;
      font-size: 14px;
    }

    .compass-direction.south {
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      color: #333;
    }

    .compass-direction.east {
      right: 2px;
      top: 50%;
      transform: translateY(-50%);
      color: #333;
    }

    .compass-direction.west {
      left: 2px;
      top: 50%;
      transform: translateY(-50%);
      color: #333;
    }

    .compass-needle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 2px;
      height: 25px;
      background: linear-gradient(to top, #666 0%, #d32f2f 70%);
      transform: translate(-50%, -100%);
      transform-origin: bottom;
      border-radius: 1px;
    }

    .compass-needle::after {
      content: '';
      position: absolute;
      top: -3px;
      left: -2px;
      width: 0;
      height: 0;
      border-left: 3px solid transparent;
      border-right: 3px solid transparent;
      border-bottom: 6px solid #d32f2f;
    }
  </style>
</head>
<body>
  <!-- Password overlay -->
  <div id="passwordOverlay">
    <div id="passwordDialog">
      <h2>Access Required</h2>
      <p>Please enter the password to access the map:</p>
      <input type="password" id="passwordInput" placeholder="Enter password">
      <button id="passwordSubmit">Submit</button>
      <div id="passwordError">Incorrect password. Please try again.</div>
    </div>
  </div>

  <div id="map"></div>
  
  <!-- Compass widget -->
  <div id="compass">
    <div class="compass-rose">
      <div class="compass-direction north">N</div>
      <div class="compass-direction south">S</div>
      <div class="compass-direction east">E</div>
      <div class="compass-direction west">W</div>
      <div class="compass-needle"></div>
    </div>
  </div>
  
  <!-- Toggle buttons -->
  <div id="toggleButtons">
    <button id="toggleNotes" class="toggle-btn">Toggle Notes</button>
    <button id="toggleMenu" class="toggle-btn">Toggle Menu</button>
  </div>
  
  <!-- Left sidebar for notes -->
  <div id="notesPanel" class="hidden">
    <div id="notesPanelHeader">
      📝 Team Notes
    </div>
    <div id="notesPanelContent">
      <div id="notesControls">
        <button id="addNote">Add Note</button>
        <button id="refreshNotes">Refresh</button>
      </div>
      <div id="notesList">
        <p id="noNotesMessage">No notes posted yet</p>
      </div>
    </div>
  </div>
  <div id="controls">
    <button id="startDraw">Start Drawing</button>
    <button id="stopDraw">Stop Drawing</button>
    <button id="clear">Clear</button>
    <label for="colorPicker">Color:</label>
    <select id="colorPicker">
      <option value="red">Red</option>
      <option value="blue">Blue</option>
      <option value="green">Green</option>
      <option value="black">Black</option>
      <option value="purple">Purple</option>
      <option value="orange">Orange</option>
    </select>
    <button id="switchView">Switch to Satellite</button>
    <button id="toggleGrid">Show Grid</button>
    <button id="toggleLabels">Hide Phone Labels</button>
    <button id="toggleDirectionArrows">Hide Direction Arrows</button>
    
    <!-- Add measurement controls after drawing controls -->
    <div style="border-top: 1px solid #ccc; margin-top: 10px; padding-top: 10px;">
      <h4>Distance Measurement</h4>
      <button id="startMeasuring">Measure Distance</button>
      <button id="clearMeasurements">Clear All Measurements</button>
      <div id="measurementInfo" style="margin-top: 8px; display: none;">
        <p style="margin: 0; font-size: 14px; color: #555;">Click two points to measure distance</p>
      </div>
    </div>

    <!-- Add POI controls -->
    <div style="border-top: 1px solid #ccc; margin-top: 10px; padding-top: 10px;">
      <h4>Points of Interest</h4>
      <button id="startPlacingPin">Place New Pin</button>
      <button id="togglePins">Hide Pins</button>
      <button id="clearAllPins">Clear All Pins</button>
      <div id="pinDialog" style="display: none; margin-top: 8px;">
        <input type="text" id="pinTitle" placeholder="Title" style="margin-bottom: 4px;">
        <textarea id="pinDescription" placeholder="Description (optional)" style="width: 100%; height: 50px;"></textarea>
        <select id="pinColor" style="margin-top: 4px;">
          <option value="#FF0000">Red</option>
          <option value="#0000FF">Blue</option>
          <option value="#008000">Green</option>
          <option value="#FFA500">Orange</option>
          <option value="#800080">Purple</option>
          <option value="#000000">Black</option>
        </select>
        <div style="display: flex; margin-top: 4px;">
          <button id="savePin" style="flex: 1; margin-right: 4px;">Save</button>
          <button id="cancelPin" style="flex: 1;">Cancel</button>
        </div>
      </div>
    </div>
    
    <div id="phoneList">
      <h4>Tracked Phones</h4>
      <div id="phoneEntries"></div>
      <button id="clearAllPhones">Clear All Phones</button>
    </div>
  </div>

  <!-- Note input dialog -->
  <div id="noteDialog">
    <h3>Add Team Note</h3>
    <textarea id="noteContent" placeholder="Enter your note here..."></textarea>
    <div class="note-dialog-buttons">
      <button id="cancelNoteBtn">Cancel</button>
      <button id="saveNoteBtn">Post Note</button>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // Password protection
    const correctPassword = "1234";
    
    function checkPassword() {
      const passwordInput = document.getElementById('passwordInput');
      const passwordError = document.getElementById('passwordError');
      const passwordOverlay = document.getElementById('passwordOverlay');
      
      if (passwordInput.value === correctPassword) {
        passwordOverlay.style.display = 'none';
        initializeMap();
      } else {
        passwordError.style.display = 'block';
        passwordInput.value = '';
        passwordInput.focus();
      }
    }
    
    document.getElementById('passwordSubmit').addEventListener('click', checkPassword);
    document.getElementById('passwordInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        checkPassword();
      }
    });
    
    // Focus on password input when page loads
    window.onload = function() {
      document.getElementById('passwordInput').focus();
    };
    
    function initializeMap() {
    const streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png');
    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}');
    const map = L.map('map', { center: [37.7749, -122.4194], zoom: 5, layers: [streetLayer] });
    let currentBaseLayer = 'street';

    document.getElementById("switchView").onclick = function () {
      if (currentBaseLayer === 'street') {
        map.removeLayer(streetLayer); map.addLayer(satelliteLayer);
        currentBaseLayer = 'satellite'; this.innerText = "Switch to Street View";
      } else {
        map.removeLayer(satelliteLayer); map.addLayer(streetLayer);
        currentBaseLayer = 'street'; this.innerText = "Switch to Satellite";
      }
    };

    let drawing = false, currentLine = null, color = document.getElementById("colorPicker").value;
    let drawnItems = [];
    let lastLoadedDrawings = [];
    
    let lastUpdateTime = 0;

    document.getElementById("startDraw").onclick = () => { drawing = true; disableMapInteraction(); };
    document.getElementById("stopDraw").onclick = () => { drawing = false; currentLine = null; enableMapInteraction(); };
    
    document.getElementById("clear").onclick = () => { 
      drawnItems.forEach(line => map.removeLayer(line)); 
      drawnItems = []; 
      fetch("/save", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify([])
      });
    };
    
    document.getElementById("colorPicker").onchange = (e) => { color = e.target.value; };

    map.on("mousedown", function (e) {
      if (!drawing) return;
      currentLine = L.polyline([e.latlng], { color: color, weight: 3 }).addTo(map);
      currentLine.options.drawingColor = color;
      drawnItems.push(currentLine);
      
      // Add right-click context menu for deletion
      currentLine.on('contextmenu', function(evt) {
        evt.originalEvent.preventDefault(); // Prevent default browser context menu
        if (confirm('Delete this line?')) {
          deleteLine(this);
        }
      });
      
      map.on("mousemove", onMouseMove);
      map.once("mouseup", () => { 
        map.off("mousemove", onMouseMove);
        saveDrawing(currentLine);
        currentLine = null; 
      });
    });

    function onMouseMove(e) {
      if (currentLine) currentLine.addLatLng(e.latlng);
    }

    function disableMapInteraction() {
      map.dragging.disable(); map.scrollWheelZoom.disable();
      map.doubleClickZoom.disable(); map.boxZoom.disable();
      map.keyboard.disable(); map.getContainer().style.cursor = 'crosshair';
    }

    function enableMapInteraction() {
      map.dragging.enable(); map.scrollWheelZoom.enable();
      map.doubleClickZoom.enable(); map.boxZoom.enable();
      map.keyboard.enable(); map.getContainer().style.cursor = '';
    }

    function deleteLine(line) {
      // Remove from map
      map.removeLayer(line);
      
      // Remove from drawnItems array
      const index = drawnItems.indexOf(line);
      if (index > -1) {
        drawnItems.splice(index, 1);
      }
      
      // Save updated drawings to server
      saveDrawings();
    }

    function saveDrawing(line) {
      // Instead of saving just the current line, save all drawings
      saveDrawings();
    }

    function saveDrawings() {
      const geojson = drawnItems.map(line => {
        const geo = line.toGeoJSON();
        geo.properties = { color: line.options.drawingColor };
        return geo;
      });
      
      fetch("/save", {
        method: "POST", 
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(geojson)
      }).then(res => res.json())
        .then(data => console.log("Saved all drawings:", data))
        .catch(err => console.error("Error saving drawings:", err));
    }

    function loadDrawings() {
      fetch("/load")
        .then(res => res.json())
        .then(data => {
          // Only update if the data has actually changed
          if (JSON.stringify(data) !== JSON.stringify(lastLoadedDrawings)) {
            drawnItems.forEach(line => map.removeLayer(line));
            drawnItems = [];
            
            data.forEach(feature => {
              const color = feature.properties?.color || 'red';
              const line = L.geoJSON(feature, { 
                style: { color: color, weight: 3 }
              }).addTo(map);
              line.options.drawingColor = color;
              
              // Add right-click context menu for deletion to loaded lines
              line.on('contextmenu', function(evt) {
                evt.originalEvent.preventDefault(); // Prevent default browser context menu
                if (confirm('Delete this line?')) {
                  deleteLine(this);
                }
              });
              
              drawnItems.push(line);
            });
            
            lastLoadedDrawings = data;
          }
        })
        .catch(err => console.error("Error loading drawings:", err));
    }

    const phones = {};

    function updateAllPhones() {
      fetch("/load_phones")
        .then(res => res.json())
        .then(data => {
          Object.keys(data).forEach(id => {
            const lat = data[id].lat;
            const lng = data[id].lng;
            const heading = data[id].heading;
            const alt = data[id].alt;
            if (typeof lat !== 'number' || typeof lng !== 'number') return;
            const latlng = [lat, lng];

            if (phones[id] && phones[id].marker) {
              // Update existing phone position
              phones[id].marker.setLatLng(latlng);
              phones[id].label.setLatLng(latlng);
              phones[id].alt = alt; // Store altitude

              // Only update heading if a new valid one is received
              if (typeof heading === 'number') {
                phones[id].heading = heading; 
              }
              
              // Update or create direction arrow if we have a heading stored
              if (typeof phones[id].heading === 'number') {
                if (phones[id].directionArrow) {
                  // Update existing arrow: move it and only rotate if new heading is available
                  phones[id].directionArrow.setLatLng(latlng);
                  if (typeof heading === 'number') {
                    phones[id].directionArrow.setIcon(createDirectionArrowIcon(heading));
                  }
                } else {
                  // Create new direction arrow if one doesn't exist
                  phones[id].directionArrow = createDirectionArrow(latlng, phones[id].heading);
                }
              }
              // If no heading is received and no arrow exists, do nothing.
              
            } else {
              // Create new phone
              phones[id] = { alt: alt }; // Initialize phone object with altitude
              if (typeof heading === 'number') {
                phones[id].heading = heading;
              }
              
              phones[id].marker = L.marker(latlng, {
                icon: L.icon({
                  iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684908.png',
                  iconSize: [32, 32], iconAnchor: [16, 32]
                })
              }).addTo(map);
              
              phones[id].label = L.marker(latlng, {
                icon: L.divIcon({
                  className: 'phone-label', html: id, iconAnchor: [-5, -10]
                })
              }).addTo(map);
              
              // Create direction arrow if heading data is available
              if (typeof phones[id].heading === 'number') {
                phones[id].directionArrow = createDirectionArrow(latlng, phones[id].heading);
              }
            }
          });

          // Remove markers for phones that are no longer in the data
          Object.keys(phones).forEach(id => {
            if (!data[id]) {
              if (phones[id].marker) map.removeLayer(phones[id].marker);
              if (phones[id].label) map.removeLayer(phones[id].label);
              if (phones[id].directionArrow) map.removeLayer(phones[id].directionArrow);
              delete phones[id];
            }
          });

          updatePhoneList();
        })
        .catch(err => console.error("Failed to load phones:", err));
    }

    function createDirectionArrowIcon(heading) {
      return L.divIcon({
        className: 'direction-arrow',
        html: `<div style="
          width: 50px; 
          height: 50px; 
          position: relative;
          transform: rotate(${heading}deg);
          pointer-events: none;
        ">
          <div style="
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 24px solid #ff4444;
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.5));
          "></div>
        </div>`,
        iconSize: [50, 50],
        iconAnchor: [25, 25]
      });
    }

    function createDirectionArrow(latlng, heading) {
      const arrow = L.marker(latlng, {
        icon: createDirectionArrowIcon(heading)
      }).addTo(map);
      
      // Set initial opacity based on current visibility setting
      arrow.setOpacity(directionArrowsVisible ? 1 : 0);
      
      return arrow;
    }

    function updatePhoneList() {
      const phoneEntries = document.getElementById('phoneEntries');
      phoneEntries.innerHTML = '';
      const ids = Object.keys(phones);
      if (ids.length === 0) {
        phoneEntries.innerHTML = '<p>No phones being tracked</p>';
      } else {
        ids.forEach(id => {
          const entry = document.createElement('div');
          entry.className = 'phone-entry';
          const text = document.createElement('span');
          let displayText = `${id}`;
          if (typeof phones[id].heading === 'number') {
            const heading = Math.round(phones[id].heading);
            const cardinalDir = getCardinalDirection(heading);
            displayText += ` - ${cardinalDir} (${heading}°)`;
          }
          if (typeof phones[id].alt === 'number') {
            displayText += ` | Alt: ${phones[id].alt.toFixed(1)}m`;
          }
          text.textContent = displayText;
          entry.appendChild(text);
          phoneEntries.appendChild(entry);
        });
      }
    }

    function getCardinalDirection(heading) {
      const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      const index = Math.round(heading / 45) % 8;
      return directions[index];
    }

    let phoneLabelsVisible = true;

    function togglePhoneLabels() {
      phoneLabelsVisible = !phoneLabelsVisible;
      Object.keys(phones).forEach(id => {
        if (phones[id].label) {
          phones[id].label.setOpacity(phoneLabelsVisible ? 1 : 0);
        }
      });
      document.getElementById("toggleLabels").innerText =
        phoneLabelsVisible ? "Hide Phone Labels" : "Show Phone Labels";
    }

    let directionArrowsVisible = true;

    function toggleDirectionArrows() {
      directionArrowsVisible = !directionArrowsVisible;
      Object.keys(phones).forEach(id => {
        if (phones[id].directionArrow) {
          phones[id].directionArrow.setOpacity(directionArrowsVisible ? 1 : 0);
        }
      });
      document.getElementById("toggleDirectionArrows").innerText =
        directionArrowsVisible ? "Hide Direction Arrows" : "Show Direction Arrows";
    }

    function clearAllPhones() {
      if (confirm("Are you sure you want to clear all tracked phones? This cannot be undone.")) {
        // Clear phones from map
        Object.keys(phones).forEach(id => {
          if (phones[id].marker) map.removeLayer(phones[id].marker);
          if (phones[id].label) map.removeLayer(phones[id].label);
          if (phones[id].directionArrow) map.removeLayer(phones[id].directionArrow);
        });
        
        // Clear phones object
        Object.keys(phones).forEach(id => {
          delete phones[id];
        });
        
        // Send request to clear phones on server
        fetch("/save_phones", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({})
        })
        .then(res => res.json())
        .then(data => {
          console.log("Cleared all phones");
          updatePhoneList(); // Update the UI
        })
        .catch(err => console.error("Error clearing phones:", err));
      }
    }

    // Grid implementation with fixed global reference
    let gridVisible = false;
    let gridLayer = null;
    let gridLabels = [];
    const MIN_ZOOM_FOR_GRID = 14; // Only show grid at very zoomed in levels
    const MAX_ZOOM_FOR_GRID = 22; // No upper limit (or use max zoom level supported)
    const GRID_SIZE = 0.005; // Tiny grid size for close-up view
    const MAX_CELLS = 250; // Limited number of cells to prevent performance issues

    function createGrid() {
      // Remove existing grid if any
      if (gridLayer) {
        map.removeLayer(gridLayer);
        gridLabels.forEach(label => map.removeLayer(label));
        gridLabels = [];
      }
      
      // Only create grid if it should be visible
      if (!gridVisible) return;
      
      // Check if current zoom level is appropriate for the grid
      const currentZoom = map.getZoom();
      if (currentZoom < MIN_ZOOM_FOR_GRID) {
        document.getElementById("toggleGrid").innerText = "Show Grid (Zoom in more)";
        document.getElementById("toggleGrid").style.opacity = "0.7";
        console.log("Grid disabled: Not zoomed in enough (" + currentZoom + ")");
        return; // Don't create grid when not zoomed in enough
      }
      
      console.log("Creating grid with fixed GRID_SIZE: " + GRID_SIZE + " at zoom level: " + currentZoom);
      
      gridLayer = L.layerGroup().addTo(map);
      
      // Get map bounds
      const bounds = map.getBounds();
      const north = bounds.getNorth();
      const south = bounds.getSouth();
      const east = bounds.getEast();
      const west = bounds.getWest();
      
      // Calculate grid start positions (align with global grid)
      const startLng = Math.floor(west / GRID_SIZE) * GRID_SIZE;
      const startLat = Math.floor(south / GRID_SIZE) * GRID_SIZE;
      const endLng = Math.ceil(east / GRID_SIZE) * GRID_SIZE;
      const endLat = Math.ceil(north / GRID_SIZE) * GRID_SIZE;
      
      // Calculate cell count based on actual grid size
      const cellCount = Math.ceil((endLat - startLat) / GRID_SIZE) * Math.ceil((endLng - startLng) / GRID_SIZE);
      
      if (cellCount > MAX_CELLS) {
        console.log("Grid disabled: Too many cells (" + cellCount + " > " + MAX_CELLS + ")");
        map.removeLayer(gridLayer);
        document.getElementById("toggleGrid").innerText = "Show Grid (Zoom in more)";
        document.getElementById("toggleGrid").style.opacity = "0.7";
        return;
      }
      
      document.getElementById("toggleGrid").innerText = "Hide Grid";
      document.getElementById("toggleGrid").style.opacity = "1";
      
      // Create vertical grid lines
      for (let lng = startLng; lng <= endLng; lng += GRID_SIZE) {
        L.polyline([[south, lng], [north, lng]], {
          color: 'rgba(0,0,0,0.5)',
          weight: 1,
          dashArray: '2,2'
        }).addTo(gridLayer);
      }
      
      // Create horizontal grid lines
      for (let lat = startLat; lat <= endLat; lat += GRID_SIZE) {
        L.polyline([[lat, west], [lat, east]], {
          color: 'rgba(0,0,0,0.5)',
          weight: 1,
          dashArray: '2,2'
        }).addTo(gridLayer);
      }
      
      // Add grid labels with fixed global references
      for (let lat = startLat; lat <= endLat; lat += GRID_SIZE) {
        for (let lng = startLng; lng <= endLng; lng += GRID_SIZE) {
          // Calculate global reference values based on absolute position
          const letterIndex = Math.floor((lng + 180) / GRID_SIZE);
          const numberIndex = Math.floor((lat + 90) / GRID_SIZE);
          
          // Create consistent global grid references
          let letter = '';
          let letterValue = letterIndex;
          
          // Convert to multi-letter (AA, AB, etc.) for values over 26
          do {
            letter = String.fromCharCode(65 + (letterValue % 26)) + letter;
            letterValue = Math.floor(letterValue / 26) - 1;
          } while (letterValue >= 0);
          
          const gridRef = letter + numberIndex;
          
          const label = L.marker([lat + GRID_SIZE/2, lng + GRID_SIZE/2], {
            icon: L.divIcon({
              className: 'grid-label',
              html: gridRef,
              iconSize: [40, 20],
              iconAnchor: [20, 10]
            })
          }).addTo(gridLayer);
          gridLabels.push(label);
        }
      }
    }

    document.getElementById("toggleGrid").addEventListener('click', function() {
      gridVisible = !gridVisible;
      
      if (gridVisible) {
        createGrid();
        // When showing grid, add zoom end handler to recreate grid
        map.on('zoomend moveend', createGrid);
      } else {
        if (gridLayer) {
          map.removeLayer(gridLayer);
          gridLabels.forEach(label => map.removeLayer(label));
          gridLabels = [];
        }
        this.innerText = "Show Grid";
        this.style.opacity = "1";
        
        // Remove handler when grid is hidden
        map.off('zoomend moveend', createGrid);
      }
    });

    // POI pins implementation
    let pins = [];
    let pinsVisible = true;
    let placingPin = false;
    let pinsLayer = L.layerGroup().addTo(map);

    function createPinMarker(poi) {
      const marker = L.marker([poi.lat, poi.lng], {
        icon: L.divIcon({
          className: 'poi-marker',
          html: `<svg width="24" height="36" viewBox="0 0 24 36" fill="${poi.color}" 
                 xmlns="http://www.w3.org/2000/svg">
                 <path d="M12 0C5.4 0 0 5.4 0 12c0 7.2 12 24 12 24s12-16.8 12-24c0-6.6-5.4-12-12-12z" 
                 stroke="#000" stroke-width="1"/>
                 </svg>`,
          iconSize: [24, 36],
          iconAnchor: [12, 36],
          popupAnchor: [0, -36]
        })
      }).addTo(pinsLayer);

      const popupContent = `
        <div class="poi-title">${poi.title}</div>
        <div class="poi-description">${poi.description || ''}</div>
        <button class="delete-poi-btn" style="margin-top: 8px; background-color: #ff4444; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; width: 100%;" 
          data-poi-id="${poi.id}">Delete Pin</button>
      `;
      
      marker.bindPopup(popupContent, {
        className: 'poi-popup',
        closeButton: true
      });
      
      // Store reference to original POI data
      marker.poi = poi;

      // Add event listener for delete button after popup opens
      marker.on('popupopen', function() {
        document.querySelector('.delete-poi-btn[data-poi-id="'+poi.id+'"]').addEventListener('click', function() {
          deletePOI(poi.id);
          map.closePopup();
        });
      });

      return marker;
    }

    function savePOI(poi) {
      fetch("/save_poi", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(poi)
      })
      .then(res => res.json())
      .then(data => {
        console.log("Saved POI:", data);
        loadPOIs(); // Refresh to ensure consistency
      })
      .catch(err => console.error("Error saving POI:", err));
    }

    function loadPOIs() {
      fetch("/load_pois")
        .then(res => res.json())
        .then(data => {
          // Clear existing pins
          pinsLayer.clearLayers();
          pins = [];
          
          // Add all pins from server
          data.forEach(poi => {
            const marker = createPinMarker(poi);
            pins.push(marker);
          });
        })
        .catch(err => console.error("Error loading POIs:", err));
    }

    function deletePOI(poiId) {
      fetch("/delete_poi", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id: poiId })
      })
      .then(res => res.json())
      .then(data => {
        console.log("Deleted POI:", data);
        loadPOIs(); // Refresh pins after deletion
      })
      .catch(err => console.error("Error deleting POI:", err));
    }

    function clearAllPins() {
      if (confirm("Are you sure you want to delete all pins? This cannot be undone.")) {
        // Clear pins from map
        pinsLayer.clearLayers();
        pins = [];
        
        // Send request to clear all POIs on server
        fetch("/clear_pois", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({})
        })
        .then(res => res.json())
        .then(data => {
          console.log("Cleared all POIs");
        })
        .catch(err => console.error("Error clearing POIs:", err));
      }
    }

    // Pin placement mode
    document.getElementById("startPlacingPin").addEventListener('click', function() {
      placingPin = true;
      this.disabled = true;
      map.getContainer().style.cursor = 'crosshair';
      
      // One-time click handler for pin placement
      const clickHandler = function(e) {
        document.getElementById("pinDialog").style.display = "block";
        document.getElementById("startPlacingPin").disabled = false;
        
        document.getElementById("savePin").onclick = function() {
          const title = document.getElementById("pinTitle").value;
          if (!title) {
            alert("Please enter a title for the pin");
            return;
          }
          
          const poi = {
            id: Date.now().toString(), // Generate unique ID
            lat: e.latlng.lat,
            lng: e.latlng.lng,
            title: title,
            description: document.getElementById("pinDescription").value,
            color: document.getElementById("pinColor").value
          };
          
          savePOI(poi);
          
          // Reset UI
          document.getElementById("pinDialog").style.display = "none";
          document.getElementById("pinTitle").value = "";
          document.getElementById("pinDescription").value = "";
          map.getContainer().style.cursor = '';
        };
        
        document.getElementById("cancelPin").onclick = function() {
          document.getElementById("pinDialog").style.display = "none";
          map.getContainer().style.cursor = '';
        };
        
        placingPin = false;
        map.off('click', clickHandler);
      };
      
      map.once('click', clickHandler);
    });

    // Toggle pins visibility
    document.getElementById("togglePins").addEventListener('click', function() {
      pinsVisible = !pinsVisible;
      if (pinsVisible) {
        map.addLayer(pinsLayer);
        this.innerText = "Hide Pins";
      } else {
        map.removeLayer(pinsLayer);
        this.innerText = "Show Pins";
      }
    });

    document.getElementById("clearAllPins").addEventListener('click', clearAllPins);
    document.getElementById("clearAllPhones").addEventListener('click', clearAllPhones);

    // Distance measurement implementation
    let measuring = false;
    let measureStart = null;
    let measurements = [];
    let measurementsLayer = L.layerGroup().addTo(map);
    
    function startMeasuring() {
      measuring = true;
      measureStart = null;
      document.getElementById('startMeasuring').innerText = 'Cancel Measuring';
      document.getElementById('measurementInfo').style.display = 'block';
      map.getContainer().style.cursor = 'crosshair';
    }
    
    function stopMeasuring() {
      measuring = false;
      measureStart = null;
      document.getElementById('startMeasuring').innerText = 'Measure Distance';
      document.getElementById('measurementInfo').style.display = 'none';
      map.getContainer().style.cursor = '';
    }
    
    map.on('click', function(e) {
      if (!measuring) return;
      
      if (measureStart === null) {
        // First point clicked
        measureStart = e.latlng;
      } else {
        // Second point clicked, create the measurement line
        const measureEnd = e.latlng;
        
        // Calculate distance in meters and yards
        const distanceMeters = measureStart.distanceTo(measureEnd);
        const distanceYards = distanceMeters * 1.09361;
        
        // Create a measurement object
        const measurement = {
          id: Date.now().toString(),
          start: [measureStart.lat, measureStart.lng],
          end: [measureEnd.lat, measureEnd.lng],
          distanceMeters: Math.round(distanceMeters),
          distanceYards: Math.round(distanceYards)
        };
        
        // Add to local measurements and draw
        addMeasurementLine(measurement);
        
        // Save to server
        saveMeasurement(measurement);
        
        // Reset for next measurement
        measureStart = null;
      }
    });
    
    function addMeasurementLine(measurement) {
      const line = L.polyline([measurement.start, measurement.end], {
        color: '#FF6B00',
        weight: 3,
        dashArray: '5, 5',
        opacity: 0.7
      }).addTo(measurementsLayer);
      
      // Create label with distance
      const midpoint = L.latLng(
        (measurement.start[0] + measurement.end[0]) / 2,
        (measurement.start[1] + measurement.end[1]) / 2
      );
      
      const label = L.marker(midpoint, {
        icon: L.divIcon({
          className: 'distance-label',
          html: `<div style="background-color: white; padding: 3px 8px; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">
                 <b>${measurement.distanceMeters}m</b> (${measurement.distanceYards}yds)
                 </div>`,
          iconSize: [100, 40],
          iconAnchor: [50, 20]
        })
      }).addTo(measurementsLayer);
      
      // Store reference to map objects
      measurement.line = line;
      measurement.label = label;
      measurements.push(measurement);
    }
    
    function saveMeasurement(measurement) {
      // Create a clean copy without Leaflet objects
      const cleanMeasurement = {
        id: measurement.id,
        start: measurement.start,
        end: measurement.end,
        distanceMeters: measurement.distanceMeters,
        distanceYards: measurement.distanceYards
      };
      
      fetch("/save_measurement", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(cleanMeasurement)
      })
      .then(res => res.json())
      .then(data => {
        console.log("Saved measurement:", data);
      })
      .catch(err => console.error("Error saving measurement:", err));
    }
    
    function loadMeasurements() {
      fetch("/load_measurements")
        .then(res => res.json())
        .then(data => {
          // Clear existing measurements
          measurementsLayer.clearLayers();
          measurements = [];
          
          // Add all measurements from server
          data.forEach(measurement => {
            addMeasurementLine(measurement);
          });
        })
        .catch(err => console.error("Error loading measurements:", err));
    }
    
    function clearAllMeasurements() {
      if (confirm("Are you sure you want to clear all distance measurements? This cannot be undone.")) {
        measurementsLayer.clearLayers();
        measurements = [];
        
        fetch("/clear_measurements", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({})
        })
        .then(res => res.json())
        .then(data => {
          console.log("Cleared all measurements");
        })
        .catch(err => console.error("Error clearing measurements:", err));
      }
    }
    
    document.getElementById("startMeasuring").addEventListener('click', function() {
      if (measuring) {
        stopMeasuring();
      } else {
        startMeasuring();
      }
    });
    
    document.getElementById("clearMeasurements").addEventListener('click', clearAllMeasurements);

    // Notes functionality
    let notes = [];

    function loadNotes() {
      fetch("/load_notes")
        .then(res => res.json())
        .then(data => {
          notes = data;
          displayNotes();
        })
        .catch(err => console.error("Error loading notes:", err));
    }

    function displayNotes() {
      const notesList = document.getElementById('notesList');
      const noNotesMessage = document.getElementById('noNotesMessage');
      
      // Clear existing notes
      notesList.innerHTML = '';
      
      if (notes.length === 0) {
        notesList.appendChild(noNotesMessage);
      } else {
        // Sort notes by timestamp (newest first)
        const sortedNotes = [...notes].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        sortedNotes.forEach(note => {
          const noteElement = createNoteElement(note);
          notesList.appendChild(noteElement);
        });
      }
    }

    function createNoteElement(note) {
      const noteDiv = document.createElement('div');
      noteDiv.className = 'note-item';
      
      const headerDiv = document.createElement('div');
      headerDiv.className = 'note-header';
      
      const timestampSpan = document.createElement('span');
      timestampSpan.className = 'note-timestamp';
      timestampSpan.textContent = formatTimestamp(note.timestamp);
      
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'note-delete-btn';
      deleteBtn.textContent = '×';
      deleteBtn.title = 'Delete note';
      deleteBtn.onclick = function() {
        if (confirm('Delete this note?')) {
          deleteNote(note.id);
        }
      };
      
      headerDiv.appendChild(timestampSpan);
      headerDiv.appendChild(deleteBtn);
      
      const contentDiv = document.createElement('div');
      contentDiv.className = 'note-content';
      contentDiv.textContent = note.content;
      
      noteDiv.appendChild(headerDiv);
      noteDiv.appendChild(contentDiv);
      
      return noteDiv;
    }

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMins / 60);
      const diffDays = Math.floor(diffHours / 24);
      
      if (diffMins < 1) {
        return 'Just now';
      } else if (diffMins < 60) {
        return `${diffMins}m ago`;
      } else if (diffHours < 24) {
        return `${diffHours}h ago`;
      } else if (diffDays < 7) {
        return `${diffDays}d ago`;
      } else {
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
      }
    }

    function showAddNoteDialog() {
      const dialog = document.getElementById('noteDialog');
      const textarea = document.getElementById('noteContent');
      
      textarea.value = '';
      dialog.style.display = 'block';
      textarea.focus();
    }

    function hideAddNoteDialog() {
      const dialog = document.getElementById('noteDialog');
      dialog.style.display = 'none';
    }

    function saveNote() {
      const content = document.getElementById('noteContent').value.trim();
      
      if (!content) {
        alert('Please enter a note before posting.');
        return;
      }
      
      const note = {
        id: Date.now().toString(),
        content: content,
        timestamp: new Date().toISOString()
      };
      
      fetch("/save_note", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(note)
      })
      .then(res => res.json())
      .then(data => {
        console.log("Note saved:", data);
        loadNotes(); // Refresh notes list
        hideAddNoteDialog();
      })
      .catch(err => {
        console.error("Error saving note:", err);
        alert('Failed to save note. Please try again.');
      });
    }

    function deleteNote(noteId) {
      fetch("/delete_note", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id: noteId })
      })
      .then(res => res.json())
      .then(data => {
        console.log("Note deleted:", data);
        loadNotes(); // Refresh notes list
      })
      .catch(err => {
        console.error("Error deleting note:", err);
        alert('Failed to delete note. Please try again.');
      });
    }

    // Notes event listeners
    document.getElementById('addNote').addEventListener('click', showAddNoteDialog);
    document.getElementById('refreshNotes').addEventListener('click', loadNotes);
    document.getElementById('saveNoteBtn').addEventListener('click', saveNote);
    document.getElementById('cancelNoteBtn').addEventListener('click', hideAddNoteDialog);
    
    // Allow Enter+Shift for new lines, but Enter alone posts the note
    document.getElementById('noteContent').addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        saveNote();
      }
    });
    
    // Close dialog when clicking outside
    document.getElementById('noteDialog').addEventListener('click', function(e) {
      if (e.target === this) {
        hideAddNoteDialog();
      }
    });

    loadDrawings();
    updateAllPhones();
    loadPOIs();
    loadMeasurements();
    loadNotes();
    
    setInterval(loadDrawings, 10000);  // Reduced frequency to prevent conflicts
    setInterval(updateAllPhones, 5000);
    setInterval(loadPOIs, 5000);
    setInterval(loadMeasurements, 5000);
    setInterval(loadNotes, 5000);

    // Toggle functionality for split buttons
    document.getElementById('toggleMenu').addEventListener('click', () => {
      document.getElementById('controls').classList.toggle('hidden');
    });
    
    document.getElementById('toggleNotes').addEventListener('click', () => {
      document.getElementById('notesPanel').classList.toggle('hidden');
    });
    
    // Add event listeners for phone label and direction arrow toggle buttons
    document.getElementById("toggleLabels").addEventListener('click', togglePhoneLabels);
    document.getElementById("toggleDirectionArrows").addEventListener('click', toggleDirectionArrows);
    
    } // End of initializeMap function
  </script>
</body>
</html>
