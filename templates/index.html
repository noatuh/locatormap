<!DOCTYPE html>
<html>
<head>
  <title>Leaflet Multi-Phone Tracker with Drawing</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    #map { height: 100%; width: 100%; }
    #passwordOverlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.8); z-index: 10000;
      display: flex; justify-content: center; align-items: center;
    }
    #passwordDialog {
      background: white; padding: 30px; border-radius: 10px;
      text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      min-width: 300px;
    }
    #passwordInput {
      width: 100%; padding: 10px; margin: 15px 0;
      border: 2px solid #ddd; border-radius: 5px; font-size: 16px;
    }
    #passwordSubmit {
      background-color: #007bff; color: white; border: none;
      padding: 10px 20px; border-radius: 5px; cursor: pointer;
      font-size: 16px; width: 100%;
    }
    #passwordSubmit:hover { background-color: #0056b3; }
    #passwordError {
      color: red; margin-top: 10px; display: none;
    }
    
    /* Right sidebar for map controls */
    #controls {
      position: absolute; top: 10px; right: 10px; z-index: 1000;
      background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 8px;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      width: 250px;
    }
    #controls.hidden { opacity: 0; visibility: hidden; }
    
    /* Left sidebar for notes */
    #notesPanel {
      position: fixed; top: 0; left: 0; width: 320px; height: 100%;
      background: rgba(255, 255, 255, 0.95); z-index: 1000;
      box-shadow: 2px 0 10px rgba(0,0,0,0.1);
      display: flex; flex-direction: column;
      transition: transform 0.3s ease;
    }
    #notesPanel.hidden {
      transform: translateX(-100%);
    }

    /* Right sidebar for navigation */
    #navigationPanel {
      position: fixed; top: 0; right: 0; width: 320px; height: 100%;
      background: rgba(255, 255, 255, 0.95); z-index: 1000;
      box-shadow: -2px 0 10px rgba(0,0,0,0.1);
      display: flex; flex-direction: column;
      transition: transform 0.3s ease;
    }
    #navigationPanel.hidden {
      transform: translateX(100%);
    }

    /* Right sidebar for weather */
    #weatherPanel {
      position: fixed; top: 0; right: 0; width: 320px; height: 100%;
      background: rgba(255, 255, 255, 0.95); z-index: 1000;
      box-shadow: -2px 0 10px rgba(0,0,0,0.1);
      display: flex; flex-direction: column;
      transition: transform 0.3s ease;
      transform: translateX(100%); /* Start hidden */
    }
    #weatherPanel.hidden {
      transform: translateX(100%);
    }
    #weatherPanel:not(.hidden) {
      transform: translateX(0);
    }

    /* Radio frequencies panel */
    #radioPanel {
      position: fixed; top: 0; left: 0; width: 320px; height: 100%;
      background: rgba(255, 255, 255, 0.95); z-index: 1000;
      box-shadow: 2px 0 10px rgba(0,0,0,0.1);
      display: flex; flex-direction: column;
      transition: transform 0.3s ease;
      transform: translateX(-100%); /* Start hidden */
    }
    #radioPanel.hidden {
      transform: translateX(-100%);
    }
    #radioPanel:not(.hidden) {
      transform: translateX(0);
    }

    .panel-header {
      background: #343a40; color: white; padding: 15px;
      font-size: 18px; font-weight: bold; text-align: center;
    }

    .panel-content {
      flex: 1; padding: 15px; overflow: hidden;
      display: flex; flex-direction: column;
    }
    
    #notesControls {
      margin-bottom: 15px;
      display: flex; gap: 8px;
    }
    
    #notesControls button {
      flex: 1; padding: 8px 12px; border: none; border-radius: 4px;
      cursor: pointer; font-size: 14px;
    }
    
    #addNote {
      background: #28a745; color: white;
    }
    #addNote:hover {
      background: #218838;
    }
    
    #refreshNotes {
      background: #17a2b8; color: white;
    }
    #refreshNotes:hover {
      background: #138496;
    }
    
    /* Radio frequency controls */
    #radioControls {
      margin-bottom: 15px;
      display: flex; gap: 8px;
    }
    
    #radioControls button {
      flex: 1; padding: 8px 12px; border: none; border-radius: 4px;
      cursor: pointer; font-size: 14px;
    }
    
    #saveRadio {
      background: #28a745; color: white;
    }
    #saveRadio:hover {
      background: #218838;
    }
    
    #clearRadio {
      background: #dc3545; color: white;
    }
    #clearRadio:hover {
      background: #c82333;
    }
    
    /* Radio channel grid */
    .radio-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
      padding-right: 8px;
    }
    
    .radio-channel {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: #f8f9fa;
      border-radius: 4px;
      border: 1px solid #dee2e6;
    }
    
    .radio-channel label {
      font-weight: bold;
      color: #495057;
      min-width: 30px;
      font-size: 14px;
    }
    
    .radio-channel input {
      flex: 1;
      padding: 4px 8px;
      border: 1px solid #ced4da;
      border-radius: 3px;
      font-size: 13px;
    }
    
    .radio-channel input:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
    }
    
    /* Toggle buttons at bottom */
    #toggleButtons {
      position: absolute; bottom: 15px; left: 50%;
      transform: translateX(-50%); z-index: 1100;
      width: 640px; /* Increased width for the weather button */
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .toggle-btn {
      padding: 10px 20px; border: none; background-color: white;
      border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      cursor: pointer; transition: all 0.3s ease;
      font-size: 14px; font-weight: 500;
      min-width: 120px;
      white-space: nowrap;
      text-align: center;
    }
    .toggle-btn:hover { 
      background-color: #f0f0f0; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      transform: translateY(-1px);
    }
    
    #shareLocationBtn {
        background-color: #28a745;
        color: white;
    }
    #shareLocationBtn:hover {
        background-color: #218838;
        color: white;
    }

    #toggleNotes, #toggleNavigation, #toggleMenu {
      background: linear-gradient(135deg, #007bff, #6610f2);
      color: white;
    }
    #toggleNotes:hover, #toggleNavigation:hover, #toggleMenu:hover {
      background: linear-gradient(135deg, #0056b3, #520dc2);
      color: white;
    }
    .phone-label {
      background: white; padding: 10px 20px; border-radius: 4px;
      font-size: 12px; display: inline-block;
    }
    #phoneList {
      margin-top: 10px; border-top: 1px solid #ccc; padding-top: 10px;
    }
    #phoneEntries {
      max-height: 120px; overflow-y: auto; margin-bottom: 5px;
    }
    .phone-entry {
      display: flex; align-items: center; margin-bottom: 6px;
      padding: 4px; background-color: rgba(240, 240, 240, 0.5); border-radius: 4px;
    }
    .phone-entry span {
      vertical-align: middle; line-height: 1; font-size: 14px;
    }
    
    /* Add grid and POI pin styles */
    .grid-label {
      background: transparent;
      border: none;
      padding: 2px 4px;
      font-weight: bold;
      font-size: 14px;
      text-align: center;
      text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
    }
    .poi-popup .leaflet-popup-content-wrapper {
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 8px;
    }
    .poi-popup .leaflet-popup-tip {
      background-color: rgba(255, 255, 255, 0.9);
    }
    .poi-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 5px;
    }
    .poi-description {
      font-size: 12px;
      white-space: pre-wrap;
    }

    /* Notes styles */
    #notesList {
      flex: 1;
      overflow-y: auto;
      margin-top: 8px;
    }

    #noNotesMessage {
      color: #666;
      font-style: italic;
      margin: 20px 0;
      text-align: center;
    }

    .note-item {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 10px;
      font-size: 13px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .note-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-weight: bold;
      color: #495057;
    }

    .note-timestamp {
      font-size: 11px;
      color: #6c757d;
      font-weight: normal;
    }

    .note-content {
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.4;
      color: #212529;
    }

    .note-delete-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      margin-left: 8px;
    }

    .note-delete-btn:hover {
      background: #c82333;
    }

    /* Note input dialog */
    #noteDialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border: 2px solid #333;
      border-radius: 8px;
      padding: 25px;
      z-index: 3000;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      display: none;
      min-width: 400px;
    }

    #noteDialog h3 {
      margin: 0 0 20px 0;
      color: #333;
      text-align: center;
    }

    #noteDialog textarea {
      width: 100%;
      min-height: 120px;
      margin-bottom: 15px;
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
    }

    .note-dialog-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    .note-dialog-buttons button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    #saveNoteBtn {
      background: #007bff;
      color: white;
    }

    #saveNoteBtn:hover {
      background: #0056b3;
    }

    #cancelNoteBtn {
      background: #6c757d;
      color: white;
    }

    #cancelNoteBtn:hover {
      background: #545b62;
    }

    /* Navigation styles */
    #navigationInfo {
      display: none;
      margin-top: 8px;
      padding: 8px;
      background-color: #f0f8ff;
      border-radius: 4px;
      font-size: 12px;
    }

    #routeDistance {
      font-weight: bold;
    }

    #routeInstructions {
      margin-top: 4px;
      color: #666;
    }

    .navigation-marker {
      border-radius: 50%;
      border: 3px solid #fff;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .route-line {
      z-index: 500;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      100% { transform: scale(1.2); }
    }

    .phone-marker-highlight {
      animation: pulse 1s ease-in-out infinite alternate;
    }

    /* Compass widget styles */
    #compass {
      position: fixed;
      top: 75px;
      left: 20px;
      width: 80px;
      height: 80px;
      background: rgba(255, 255, 255, 0.95);
      border: 2px solid #333;
      border-radius: 50%;
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      font-family: Arial, sans-serif;
      font-weight: bold;
    }

    .compass-rose {
      position: relative;
      width: 60px;
      height: 60px;
    }

    .compass-direction {
      position: absolute;
      font-size: 12px;
      font-weight: bold;
      color: #333;
    }

    .compass-direction.north {
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
      color: #d32f2f;
      font-size: 14px;
    }

    .compass-direction.south {
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      color: #333;
    }

    .compass-direction.east {
      right: 2px;
      top: 50%;
      transform: translateY(-50%);
      color: #333;
    }

    .compass-direction.west {
      left: 2px;
      top: 50%;
      transform: translateY(-50%);
      color: #333;
    }

    .compass-needle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 2px;
      height: 25px;
      background: linear-gradient(to top, #666 0%, #d32f2f 70%);
      transform: translate(-50%, -100%);
      transform-origin: bottom;
      border-radius: 1px;
    }

    .compass-needle::after {
      content: '';
      position: absolute;
      top: -3px;
      left: -2px;
      width: 0;
      height: 0;
      border-left: 3px solid transparent;
      border-right: 3px solid transparent;
      border-bottom: 6px solid #d32f2f;
    }

    /* Weather radar legend styles */
    #weatherLegend {
      position: fixed;
      bottom: 120px;
      left: 20px;
      background: rgba(255, 255, 255, 0.95);
      border: 2px solid #333;
      border-radius: 8px;
      padding: 12px;
      z-index: 2000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      font-family: Arial, sans-serif;
      display: none; /* Hidden by default, shown only when weather radar is active */
      min-width: 180px;
    }

    .legend-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 8px;
      text-align: center;
      color: #333;
      border-bottom: 1px solid #ddd;
      padding-bottom: 4px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
      font-size: 12px;
    }

    .legend-color {
      width: 20px;
      height: 12px;
      margin-right: 8px;
      border: 1px solid #333;
      border-radius: 2px;
    }

    .legend-label {
      color: #333;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <!-- Password overlay -->
  <div id="passwordOverlay">
    <div id="passwordDialog">
      <h2>Access Required</h2>
      <p>Please enter the password to access the map:</p>
      <input type="password" id="passwordInput" placeholder="Enter password">
      <button id="passwordSubmit">Submit</button>
      <div id="passwordError">Incorrect password. Please try again.</div>
    </div>
  </div>

  <div id="map"></div>
  
  <!-- Compass widget -->
  <div id="compass">
    <div class="compass-rose">
      <div class="compass-direction north">N</div>
      <div class="compass-direction south">S</div>
      <div class="compass-direction east">E</div>
      <div class="compass-direction west">W</div>
      <div class="compass-needle"></div>
    </div>
  </div>
  
  <!-- Weather radar legend -->
  <div id="weatherLegend">
    <div class="legend-title">🌧️ Precipitation</div>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(to right, #87CEEB, #4682B4);"></div>
      <div class="legend-label">Light</div>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(to right, #32CD32, #228B22);"></div>
      <div class="legend-label">Moderate</div>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(to right, #FFD700, #FF8C00);"></div>
      <div class="legend-label">Heavy</div>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(to right, #FF4500, #DC143C);"></div>
      <div class="legend-label">Intense</div>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: linear-gradient(to right, #8B0000, #4B0000);"></div>
      <div class="legend-label">Extreme</div>
    </div>
  </div>
  
  <!-- Toggle buttons -->
  <div id="toggleButtons">
    <button id="toggleNotes" class="toggle-btn">Toggle Notes</button>
    <button id="toggleNavigation" class="toggle-btn">Navigation</button>
    <button id="toggleRadio" class="toggle-btn">Radio Frequencies</button>
    <button id="toggleMenu" class="toggle-btn">Toggle Menu</button>
    <button id="shareLocationBtn" class="toggle-btn">Share Location </button>
    <button id="toggleCompass" class="toggle-btn">Compass</button>
    <button id="toggleWeather" class="toggle-btn">Weather Info</button>
  </div>
  
  <!-- Left sidebar for notes -->
  <div id="notesPanel" class="hidden">
    <div class="panel-header">
      📝 Team Notes
    </div>
    <div class="panel-content">
      <div id="notesControls">
        <button id="addNote">Add Note</button>
        <button id="refreshNotes">Refresh</button>
      </div>
      <div id="notesList">
        <p id="noNotesMessage">No notes posted yet</p>
      </div>
    </div>
  </div>

  <!-- Right sidebar for navigation -->
  <div id="navigationPanel" class="hidden">
    <div class="panel-header">
      🧭 Navigation
    </div>
    <div class="panel-content">
      <!-- Transportation Mode Selection -->
      <div style="margin-bottom: 15px;">
        <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">Transportation Mode:</label>
        <select id="transportMode" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px;">
          <option value="walking">🚶 Walking</option>
          <option value="driving">🚗 Driving</option>
          <option value="cycling">🚴 Cycling</option>
        </select>
      </div>
      
      <!-- Navigation Controls -->
      <div style="margin-bottom: 15px;">
        <button id="setDestination" style="width: 100%; padding: 10px; margin-bottom: 8px; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 14px; cursor: pointer;">📍 Set Destination</button>
        <button id="clearRoute" style="width: 100%; padding: 8px; background: #dc3545; color: white; border: none; border-radius: 4px; font-size: 14px; cursor: pointer;">❌ Clear Route</button>
      </div>
      
      <!-- Route Information -->
      <div id="routeInfo" style="display: none; padding: 12px; background: #f8f9fa; border-radius: 6px; margin-bottom: 15px;">
        <h5 style="margin: 0 0 8px 0; color: #333;">📊 Route Summary</h5>
        <div id="routeStats" style="font-size: 13px; color: #666; margin-bottom: 8px;"></div>
        <div id="routeStatus" style="font-size: 12px; color: #666; font-style: italic;"></div>
      </div>
      
      <!-- Turn-by-Turn Directions -->
      <div id="directionsContainer" style="display: none; margin-bottom: 15px;">
        <h5 style="margin: 0 0 10px 0; color: #333;">📋 Directions</h5>
        <div id="directionsList" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; background: white;">
          <!-- Directions will be populated here -->
        </div>
      </div>
      
      <!-- Current Location Info -->
      <div id="currentLocationInfo" style="padding: 12px; background: #e7f3ff; border-radius: 6px; margin-bottom: 15px;">
        <h5 style="margin: 0 0 8px 0; color: #333;">📍 Current Location</h5>
        <div id="locationCoords" style="font-size: 12px; color: #666;">Waiting for location...</div>
        <button id="centerOnLocation" style="width: 100%; padding: 6px; margin-top: 8px; background: #28a745; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">📌 Center Map on Me</button>
      </div>
      
      <div style="border-top: 1px solid #ccc; padding-top: 15px;">
        <h5 style="margin: 0 0 10px 0; color: #333;">Quick Destinations</h5>
        <div id="quickDestinations">
          <p style="font-size: 12px; color: #666; margin: 0;">Click on any POI pin to navigate there, or use "Set Destination" to choose a custom location.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Weather panel -->
  <div id="weatherPanel" class="hidden">
    <div class="panel-header">
      🌤️ Weather Info
    </div>
    <div class="panel-content">
      <!-- Location Input -->
      <div style="margin-bottom: 15px;">
        <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #333;">Get Weather For:</label>
        
        <!-- Tracked Device Selector -->
        <div style="margin-bottom: 8px;">
          <select id="trackedDeviceSelect" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-bottom: 4px;">
            <option value="">Select a tracked device...</option>
          </select>
          <button id="getWeatherByDevice" style="width: 100%; padding: 6px; background: #17a2b8; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">📱 Get Weather for Selected Device</button>
        </div>
        
        <!-- ZIP Code Input -->
        <div style="display: flex; gap: 4px; margin-bottom: 8px;">
          <input type="text" id="zipCodeInput" placeholder="ZIP code (e.g., 90210)" style="flex: 1; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;">
          <button id="getWeatherByZip" style="padding: 6px 12px; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">Get</button>
        </div>
        
        <button id="getWeatherByGPS" style="width: 100%; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">📍 Use Current GPS Location</button>
      </div>
      
      <!-- Weather Display -->
      <div id="weatherDisplay" style="display: none;">
        <div id="weatherLocation" style="font-weight: bold; font-size: 14px; color: #333; margin-bottom: 10px; text-align: center;"></div>
        
        <!-- Current Conditions -->
        <div style="background: #f8f9fa; border-radius: 6px; padding: 12px; margin-bottom: 10px;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <div>
              <div id="weatherTemp" style="font-size: 24px; font-weight: bold; color: #333;"></div>
              <div id="weatherDescription" style="font-size: 12px; color: #666; text-transform: capitalize;"></div>
            </div>
            <div id="weatherIcon" style="font-size: 32px;"></div>
          </div>
          
          <div style="border-top: 1px solid #ddd; padding-top: 8px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
              <div>
                <strong>Feels Like:</strong>
                <div id="weatherFeelsLike" style="color: #666;"></div>
              </div>
              <div>
                <strong>Humidity:</strong>
                <div id="weatherHumidity" style="color: #666;"></div>
              </div>
              <div>
                <strong>Wind:</strong>
                <div id="weatherWind" style="color: #666;"></div>
              </div>
              <div>
                <strong>Pressure:</strong>
                <div id="weatherPressure" style="color: #666;"></div>
              </div>
              <div>
                <strong>Visibility:</strong>
                <div id="weatherVisibility" style="color: #666;"></div>
              </div>
              <div>
                <strong>UV Index:</strong>
                <div id="weatherUV" style="color: #666;"></div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Additional Info -->
        <div style="background: #e7f3ff; border-radius: 6px; padding: 10px; font-size: 11px;">
          <div style="margin-bottom: 4px;">
            <strong>🌅 Sunrise:</strong> <span id="weatherSunrise"></span>
          </div>
          <div>
            <strong>🌇 Sunset:</strong> <span id="weatherSunset"></span>
          </div>
        </div>
        
        <div style="margin-top: 10px; text-align: center; font-size: 10px; color: #999;">
          <div id="weatherLastUpdate"></div>
          <div>Data from OpenWeatherMap</div>
        </div>
      </div>
      
      <!-- Weather Error Message -->
      <div id="weatherError" style="display: none; background: #f8d7da; color: #721c24; padding: 10px; border-radius: 4px; font-size: 12px; margin-top: 10px;">
      </div>
    </div>
  </div>

  <!-- Radio Frequencies panel -->
  <div id="radioPanel" class="hidden">
    <div class="panel-header">
      📻 Radio Frequencies
    </div>
    <div class="panel-content">
      <div id="radioControls">
        <button id="saveRadio">Save All</button>
        <button id="clearRadio">Clear All</button>
      </div>
      
      <div class="radio-grid" id="radioGrid">
        <!-- Radio channels will be generated here -->
      </div>
    </div>
  </div>

  <div id="controls">
    <button id="startDraw">Start Drawing</button>
    <button id="stopDraw">Stop Drawing</button>
    <button id="clear">Clear</button>
    <label for="colorPicker">Color:</label>
    <select id="colorPicker">
      <option value="red">Red</option>
      <option value="blue">Blue</option>
      <option value="green">Green</option>
      <option value="black">Black</option>
      <option value="purple">Purple</option>
      <option value="orange">Orange</option>
    </select>
    <button id="switchView">Switch to Satellite</button>
    <button id="toggleGrid">Show Grid</button>
    <button id="toggleLabels">Hide Phone Labels</button>
    <button id="toggleDirectionArrows">Hide Direction Arrows</button>
    
    <!-- Add measurement controls after drawing controls -->
    <div style="border-top: 1px solid #ccc; margin-top: 10px; padding-top: 10px;">
      <h4>Distance Measurement</h4>
      <button id="startMeasuring">Measure Distance</button>
      <button id="clearMeasurements">Clear All Measurements</button>
      <div id="measurementInfo" style="margin-top: 8px; display: none;">
        <p style="margin: 0; font-size: 14px; color: #555;">Click two points to measure distance</p>
      </div>
    </div>

    <!-- Add POI controls -->
    <div style="border-top: 1px solid #ccc; margin-top: 10px; padding-top: 10px;">
      <h4>Points of Interest</h4>
      <button id="startPlacingPin">Place New Pin</button>
      <button id="togglePins">Hide Pins</button>
      <button id="clearAllPins">Clear All Pins</button>
      <div id="pinDialog" style="display: none; margin-top: 8px;">
        <input type="text" id="pinTitle" placeholder="Title" style="margin-bottom: 4px;">
        <textarea id="pinDescription" placeholder="Description (optional)" style="width: 100%; height: 50px;"></textarea>
        <select id="pinColor" style="margin-top: 4px;">
          <option value="#FF0000">Red</option>
          <option value="#0000FF">Blue</option>
          <option value="#008000">Green</option>
          <option value="#FFA500">Orange</option>
          <option value="#800080">Purple</option>
          <option value="#000000">Black</option>
        </select>
        <div style="display: flex; margin-top: 4px;">
          <button id="savePin" style="flex: 1; margin-right: 4px;">Save</button>
          <button id="cancelPin" style="flex: 1;">Cancel</button>
        </div>
      </div>
    </div>
    
    <div id="phoneList">
      <h4>Tracked Phones</h4>
      <div id="followStatus" style="font-size: 12px; color: #666; margin-bottom: 8px; padding: 4px; background: rgba(255,255,255,0.8); border-radius: 3px; display: none;">
        <strong>🎯 Following:</strong> <span id="followedPhoneName"></span>
        <button id="stopFollowingBtn" style="margin-left: 8px; padding: 2px 6px; font-size: 10px; background: #dc3545; color: white; border: none; border-radius: 2px; cursor: pointer;">Stop</button>
      </div>
      <div id="phoneEntries"></div>
      <button id="clearAllPhones">Clear All Phones</button>
    </div>
  </div>

  <!-- Note input dialog -->
  <div id="noteDialog">
    <h3>Add Team Note</h3>
    <textarea id="noteContent" placeholder="Enter your note here..."></textarea>
    <div class="note-dialog-buttons">
      <button id="cancelNoteBtn">Cancel</button>
      <button id="saveNoteBtn">Post Note</button>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // Password protection
    const correctPassword = "123";
    
    function checkPassword() {
      const passwordInput = document.getElementById('passwordInput');
      const passwordError = document.getElementById('passwordError');
      const passwordOverlay = document.getElementById('passwordOverlay');
      
      if (passwordInput.value === correctPassword) {
        passwordOverlay.style.display = 'none';
        initializeMap();
      } else {
        passwordError.style.display = 'block';
        passwordInput.value = '';
        passwordInput.focus();
      }
    }
    
    document.getElementById('passwordSubmit').addEventListener('click', checkPassword);
    document.getElementById('passwordInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        checkPassword();
      }
    });
    
    // Focus on password input when page loads
    window.onload = function() {
      document.getElementById('passwordInput').focus();
    };
    
    function initializeMap() {
    const streetLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png');
    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}');
    // Weather radar layer from OpenWeatherMap
    const weatherLayer = L.tileLayer('https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=e5a22a0e01663d82908ab1cf69e7c73d', {
      attribution: 'Weather data © OpenWeatherMap',
      opacity: 0.7
    });
    // Alternative free weather radar from RainViewer
    const radarLayer = L.tileLayer('https://tilecache.rainviewer.com/v2/radar/{time}/256/{z}/{x}/{y}/2/1_1.png', {
      attribution: 'Weather data © RainViewer',
      opacity: 0.7
    });
    
    const map = L.map('map', { center: [37.7749, -122.4194], zoom: 5, layers: [streetLayer] });
    let currentBaseLayer = 'street';
    let weatherVisible = false;

    document.getElementById("switchView").onclick = function () {
      if (currentBaseLayer === 'street') {
        // Switch from Street to Satellite
        map.removeLayer(streetLayer); 
        map.addLayer(satelliteLayer);
        currentBaseLayer = 'satellite'; 
        this.innerText = "Switch to Weather Radar";
        // Hide weather legend
        document.getElementById('weatherLegend').style.display = 'none';
      } else if (currentBaseLayer === 'satellite') {
        // Switch from Satellite to Weather Radar
        map.removeLayer(satelliteLayer);
        // Add weather radar as base layer with street map underneath for context
        map.addLayer(streetLayer);
        getCurrentRadarTime().then(time => {
          const currentRadarLayer = L.tileLayer(`https://tilecache.rainviewer.com/v2/radar/${time}/256/{z}/{x}/{y}/2/1_1.png`, {
            attribution: 'Weather data © RainViewer',
            opacity: 0.8
          });
          map.addLayer(currentRadarLayer);
          // Store reference for removal later
          window.currentRadarLayer = currentRadarLayer;
        }).catch(error => {
          console.error('Failed to load weather radar:', error);
          // Fallback: use a static time
          const fallbackTime = Math.floor(Date.now() / 1000) - 600;
          const currentRadarLayer = L.tileLayer(`https://tilecache.rainviewer.com/v2/radar/${fallbackTime}/256/{z}/{x}/{y}/2/1_1.png`, {
            attribution: 'Weather data © RainViewer',
            opacity: 0.8
          });
          map.addLayer(currentRadarLayer);
          window.currentRadarLayer = currentRadarLayer;
        });
        currentBaseLayer = 'weather';
        this.innerText = "Switch to Street View";
        // Show weather legend when radar is active
        document.getElementById('weatherLegend').style.display = 'block';
      } else {
        // Switch from Weather Radar back to Street
        if (window.currentRadarLayer) {
          map.removeLayer(window.currentRadarLayer);
          window.currentRadarLayer = null;
        }
        // Street layer should already be there as base, no need to add again
        currentBaseLayer = 'street'; 
        this.innerText = "Switch to Satellite";
        // Hide weather legend when leaving radar view
        document.getElementById('weatherLegend').style.display = 'none';
      }
    };

    // Function to get current radar time from RainViewer API
    function getCurrentRadarTime() {
      return fetch('https://api.rainviewer.com/public/weather-maps.json')
        .then(response => response.json())
        .then(data => {
          console.log('RainViewer API response:', data);
          // Get the most recent radar frame from past data
          if (data.radar && data.radar.past && data.radar.past.length > 0) {
            return data.radar.past[data.radar.past.length - 1].time;
          }
          // Also check nowcast if available
          if (data.radar && data.radar.nowcast && data.radar.nowcast.length > 0) {
            return data.radar.nowcast[data.radar.nowcast.length - 1].time;
          }
          // Fallback to a recent timestamp if API fails
          console.warn('No radar data found, using fallback timestamp');
          return Math.floor(Date.now() / 1000) - 600; // 10 minutes ago
        })
        .catch(error => {
          console.error('Error fetching radar time:', error);
          return Math.floor(Date.now() / 1000) - 600; // 10 minutes ago
        });
    }

    let drawing = false, currentLine = null, color = document.getElementById("colorPicker").value;
    let drawnItems = [];
    let lastLoadedDrawings = [];
    
    let lastUpdateTime = 0;

    document.getElementById("startDraw").onclick = () => { drawing = true; disableMapInteraction(); };
    document.getElementById("stopDraw").onclick = () => { drawing = false; currentLine = null; enableMapInteraction(); };
    
    document.getElementById("clear").onclick = () => { 
      drawnItems.forEach(line => map.removeLayer(line)); 
      drawnItems = []; 
      fetch("/save", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify([])
      });
    };
    
    document.getElementById("colorPicker").onchange = (e) => { color = e.target.value; };

    map.on("mousedown", function (e) {
      if (!drawing) return;
      currentLine = L.polyline([e.latlng], { color: color, weight: 3 }).addTo(map);
      currentLine.options.drawingColor = color;
      drawnItems.push(currentLine);
      
      // Add right-click context menu for deletion
      currentLine.on('contextmenu', function(evt) {
        evt.originalEvent.preventDefault(); // Prevent default browser context menu
        if (confirm('Delete this line?')) {
          deleteLine(this);
        }
      });
      
      map.on("mousemove", onMouseMove);
      map.once("mouseup", () => { 
        map.off("mousemove", onMouseMove);
        saveDrawing(currentLine);
        currentLine = null; 
      });
    });

    function onMouseMove(e) {
      if (currentLine) currentLine.addLatLng(e.latlng);
    }

    function disableMapInteraction() {
      map.dragging.disable(); map.scrollWheelZoom.disable();
      map.doubleClickZoom.disable(); map.boxZoom.disable();
      map.keyboard.disable(); map.getContainer().style.cursor = 'crosshair';
    }

    function enableMapInteraction() {
      map.dragging.enable(); map.scrollWheelZoom.enable();
      map.doubleClickZoom.enable(); map.boxZoom.enable();
      map.keyboard.enable(); map.getContainer().style.cursor = '';
    }

    function deleteLine(line) {
      // Remove from map
      map.removeLayer(line);
      
      // Remove from drawnItems array
      const index = drawnItems.indexOf(line);
      if (index > -1) {
        drawnItems.splice(index, 1);
      }
      
      // Save updated drawings to server
      saveDrawings();
    }

    function saveDrawing(line) {
      // Instead of saving just the current line, save all drawings
      saveDrawings();
    }

    function saveDrawings() {
      const geojson = drawnItems.map(line => {
        const geo = line.toGeoJSON();
        geo.properties = { color: line.options.drawingColor };
        return geo;
      });
      
      fetch("/save", {
        method: "POST", 
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(geojson)
      }).then(res => res.json())
        .then(data => console.log("Saved all drawings:", data))
        .catch(err => console.error("Error saving drawings:", err));
    }

    function loadDrawings() {
      fetch("/load")
        .then(res => res.json())
        .then(data => {
          // Only update if the data has actually changed
          if (JSON.stringify(data) !== JSON.stringify(lastLoadedDrawings)) {
            drawnItems.forEach(line => map.removeLayer(line));
            drawnItems = [];
            
            data.forEach(feature => {
              const color = feature.properties?.color || 'red';
              const line = L.geoJSON(feature, { 
                style: { color: color, weight: 3 }
              }).addTo(map);
              line.options.drawingColor = color;
              
              // Add right-click context menu for deletion to loaded lines
              line.on('contextmenu', function(evt) {
                evt.originalEvent.preventDefault(); // Prevent default browser context menu
                if (confirm('Delete this line?')) {
                  deleteLine(this);
                }
              });
              
              drawnItems.push(line);
            });
            
            lastLoadedDrawings = data;
          }
        })
        .catch(err => console.error("Error loading drawings:", err));
    }

    const phones = {};
    let followedPhone = null; // Track which phone we're following

    function updateAllPhones() {
      return fetch("/load_phones")
        .then(res => res.json())
        .then(data => {
          Object.keys(data).forEach(id => {
            const lat = data[id].lat;
            const lng = data[id].lng;
            const heading = data[id].heading;
            const alt = data[id].alt;
            if (typeof lat !== 'number' || typeof lng !== 'number') return;
            const latlng = [lat, lng];

            if (phones[id] && phones[id].marker) {
              // Update existing phone position
              const oldLat = phones[id].lat;
              const oldLng = phones[id].lng;
              phones[id].lat = lat; // Store lat
              phones[id].lng = lng; // Store lng
              phones[id].marker.setLatLng(latlng);
              phones[id].label.setLatLng(latlng);
              phones[id].alt = alt; // Store altitude

              // If this phone is being followed and position changed, center map on it
              if (followedPhone === id && (oldLat !== lat || oldLng !== lng)) {
                map.setView([lat, lng], map.getZoom()); // Keep current zoom level
              }

              // Only update heading if a new valid one is received
              if (typeof heading === 'number') {
                phones[id].heading = heading; 
              }
              
              // Update or create direction arrow if we have a heading stored
              if (typeof phones[id].heading === 'number') {
                if (phones[id].directionArrow) {
                  // Update existing arrow: move it and only rotate if new heading is available
                  phones[id].directionArrow.setLatLng(latlng);
                  if (typeof heading === 'number') {
                    phones[id].directionArrow.setIcon(createDirectionArrowIcon(heading));
                  }
                } else {
                  // Create new direction arrow if one doesn't exist
                  phones[id].directionArrow = createDirectionArrow(latlng, phones[id].heading);
                }
              }
              // If no heading is received and no arrow exists, do nothing.
              
            } else {
              // Create new phone
              phones[id] = { lat: lat, lng: lng, alt: alt }; // Initialize phone object with lat, lng, and altitude
              if (typeof heading === 'number') {
                phones[id].heading = heading;
              }
              
              phones[id].marker = L.marker(latlng, {
                icon: L.icon({
                  iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684908.png',
                  iconSize: [32, 32], iconAnchor: [16, 32]
                })
              }).addTo(map);
              
              phones[id].label = L.marker(latlng, {
                icon: L.divIcon({
                  className: 'phone-label', html: id, iconAnchor: [-5, -10]
                })
              }).addTo(map);
              
              // Create direction arrow if heading data is available
              if (typeof phones[id].heading === 'number') {
                phones[id].directionArrow = createDirectionArrow(latlng, phones[id].heading);
              }
            }
          });

          // Remove markers for phones that are no longer in the data
          Object.keys(phones).forEach(id => {
            if (!data[id]) {
              if (phones[id].marker) map.removeLayer(phones[id].marker);
              if (phones[id].label) map.removeLayer(phones[id].label);
              if (phones[id].directionArrow) map.removeLayer(phones[id].directionArrow);
              
              // If we were following this phone, stop following
              if (followedPhone === id) {
                followedPhone = null;
                console.log(`Stopped following phone ${id} (device disconnected)`);
              }
              
              delete phones[id];
            }
          });

          updatePhoneList();
          updateTrackedDeviceSelect(); // Update weather device selector
        })
        .catch(err => console.error("Failed to load phones:", err));
    }

    function toggleFollowPhone(phoneId) {
      if (followedPhone === phoneId) {
        // Stop following this phone
        followedPhone = null;
        console.log(`Stopped following phone: ${phoneId}`);
      } else {
        // Start following this phone
        followedPhone = phoneId;
        console.log(`Now following phone: ${phoneId}`);
        
        // Immediately center on the phone
        if (phones[phoneId] && phones[phoneId].lat !== undefined && phones[phoneId].lng !== undefined) {
          map.setView([phones[phoneId].lat, phones[phoneId].lng], Math.max(map.getZoom(), 16));
        }
      }
      
      // Update the phone list display to reflect the change
      updatePhoneList();
    }

    function removeSpecificPhone(phoneId) {
      if (confirm(`Are you sure you want to remove device "${phoneId}" from tracking? This cannot be undone.`)) {
        // Remove from map
        if (phones[phoneId]) {
          if (phones[phoneId].marker) map.removeLayer(phones[phoneId].marker);
          if (phones[phoneId].label) map.removeLayer(phones[phoneId].label);
          if (phones[phoneId].directionArrow) map.removeLayer(phones[phoneId].directionArrow);
          
          // If we were following this phone, stop following
          if (followedPhone === phoneId) {
            followedPhone = null;
            console.log(`Stopped following phone ${phoneId} (device removed)`);
          }
          
          // If this was the navigation origin, clear it
          if (navigationOriginPhone === phoneId) {
            clearNavigationOrigin();
            console.log(`Cleared navigation origin ${phoneId} (device removed)`);
          }
          
          // Remove from local phones object
          delete phones[phoneId];
        }
        
        // Get all remaining phones and send to server
        const remainingPhones = {};
        Object.keys(phones).forEach(id => {
          if (phones[id] && phones[id].lat !== undefined && phones[id].lng !== undefined) {
            remainingPhones[id] = {
              lat: phones[id].lat,
              lng: phones[id].lng,
              heading: phones[id].heading,
              alt: phones[id].alt
            };
          }
        });
        
        // Send updated phones list to server
        fetch("/save_phones", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(remainingPhones)
        })
        .then(res => res.json())
        .then(data => {
          console.log(`Removed phone ${phoneId} from server`);
          updatePhoneList(); // Update the UI
        })
        .catch(err => console.error("Error removing phone:", err));
      }
    }

    function createDirectionArrowIcon(heading) {
      return L.divIcon({
        className: 'direction-arrow',
        html: `<div style="
          width: 50px; 
          height: 50px; 
          position: relative;
          transform: rotate(${heading}deg);
          pointer-events: none;
        ">
          <div style="
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 24px solid #ff4444;
            filter: drop-shadow(0 0 3px rgba(0,0,0,0.5));
          "></div>
        </div>`,
        iconSize: [50, 50],
        iconAnchor: [25, 25]
      });
    }

    function createDirectionArrow(latlng, heading) {
      const arrow = L.marker(latlng, {
        icon: createDirectionArrowIcon(heading)
      }).addTo(map);
      
      // Set initial opacity based on current visibility setting
      arrow.setOpacity(directionArrowsVisible ? 1 : 0);
      
      return arrow;
    }

    function updatePhoneList() {
      const phoneEntries = document.getElementById('phoneEntries');
      const followStatus = document.getElementById('followStatus');
      const followedPhoneName = document.getElementById('followedPhoneName');
      
      phoneEntries.innerHTML = '';
      
      // Update follow status display
      if (followedPhone) {
        followStatus.style.display = 'block';
        followedPhoneName.textContent = followedPhone;
        
        // Add event listener for stop following button
        const stopBtn = document.getElementById('stopFollowingBtn');
        if (stopBtn) {
          stopBtn.onclick = () => {
            followedPhone = null;
            updatePhoneList();
          };
        }
      } else {
        followStatus.style.display = 'none';
      }
      
      const ids = Object.keys(phones);
      if (ids.length === 0) {
        phoneEntries.innerHTML = '<p>No phones being tracked</p>';
      } else {
        ids.forEach(id => {
          const entry = document.createElement('div');
          entry.className = 'phone-entry';
          entry.style.display = 'flex';
          entry.style.flexDirection = 'column';
          entry.style.marginBottom = '8px';
          entry.style.padding = '8px';
          entry.style.backgroundColor = followedPhone === id ? 'rgba(40, 167, 69, 0.2)' : 'rgba(240, 240, 240, 0.8)';
          entry.style.borderRadius = '4px';
          entry.style.border = followedPhone === id ? '2px solid #28a745' : 'none';
          
          // Phone info text
          const text = document.createElement('div');
          let displayText = `📱 ${id}`;
          if (followedPhone === id) {
            displayText += ' 🎯'; // Target icon for followed phone
          }
          if (typeof phones[id].heading === 'number') {
            const heading = Math.round(phones[id].heading);
            const cardinalDir = getCardinalDirection(heading);
            displayText += ` - ${cardinalDir} (${heading}°)`;
          }
          if (typeof phones[id].alt === 'number') {
            displayText += ` | Alt: ${phones[id].alt.toFixed(1)}m`;
          }
          text.textContent = displayText;
          text.style.fontSize = '13px';
          text.style.marginBottom = '6px';
          text.style.fontWeight = followedPhone === id ? 'bold' : 'normal';
          
          // Button container - First row (main actions)
          const buttonContainer1 = document.createElement('div');
          buttonContainer1.style.display = 'flex';
          buttonContainer1.style.gap = '4px';
          buttonContainer1.style.marginBottom = '4px';
          
          // Center map button
          const centerBtn = document.createElement('button');
          centerBtn.textContent = 'Center';
          centerBtn.style.flex = '1';
          centerBtn.style.padding = '4px 8px';
          centerBtn.style.fontSize = '11px';
          centerBtn.style.backgroundColor = '#28a745';
          centerBtn.style.color = 'white';
          centerBtn.style.border = 'none';
          centerBtn.style.borderRadius = '3px';
          centerBtn.style.cursor = 'pointer';
          centerBtn.onclick = () => centerOnPhone(id);
          
          // Follow/Unfollow button
          const followBtn = document.createElement('button');
          followBtn.textContent = followedPhone === id ? 'Unfollow' : 'Follow';
          followBtn.style.flex = '1';
          followBtn.style.padding = '4px 8px';
          followBtn.style.fontSize = '11px';
          followBtn.style.backgroundColor = followedPhone === id ? '#dc3545' : '#17a2b8';
          followBtn.style.color = 'white';
          followBtn.style.border = 'none';
          followBtn.style.borderRadius = '3px';
          followBtn.style.cursor = 'pointer';
          followBtn.onclick = () => toggleFollowPhone(id);
          
          // Navigate from button
          const navBtn = document.createElement('button');
          navBtn.textContent = 'Nav From';
          navBtn.style.flex = '1';
          navBtn.style.padding = '4px 8px';
          navBtn.style.fontSize = '11px';
          navBtn.style.backgroundColor = '#007bff';
          navBtn.style.color = 'white';
          navBtn.style.border = 'none';
          navBtn.style.borderRadius = '3px';
          navBtn.style.cursor = 'pointer';
          navBtn.onclick = () => setNavigationOrigin(id);
          
          buttonContainer1.appendChild(centerBtn);
          buttonContainer1.appendChild(followBtn);
          buttonContainer1.appendChild(navBtn);
          
          // Button container - Second row (delete action)
          const buttonContainer2 = document.createElement('div');
          buttonContainer2.style.display = 'flex';
          buttonContainer2.style.gap = '4px';
          
          // Delete this phone button
          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = '🗑️ Remove Device';
          deleteBtn.style.flex = '1';
          deleteBtn.style.padding = '4px 8px';
          deleteBtn.style.fontSize = '11px';
          deleteBtn.style.backgroundColor = '#dc3545';
          deleteBtn.style.color = 'white';
          deleteBtn.style.border = 'none';
          deleteBtn.style.borderRadius = '3px';
          deleteBtn.style.cursor = 'pointer';
          deleteBtn.onclick = () => removeSpecificPhone(id);
          
          buttonContainer2.appendChild(deleteBtn);
          
          entry.appendChild(text);
          entry.appendChild(buttonContainer1);
          entry.appendChild(buttonContainer2);
          phoneEntries.appendChild(entry);
        });
      }
    }

    function getCardinalDirection(heading) {
      const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      const index = Math.round(heading / 45) % 8;
      return directions[index];
    }

    async function centerOnPhone(phoneId) {
      await updateAllPhones(); // Ensure data is fresh
      if (phones[phoneId] && phones[phoneId].lat !== undefined && phones[phoneId].lng !== undefined) {
        map.setView([phones[phoneId].lat, phones[phoneId].lng], 16);
        
        // Optional: highlight the phone temporarily
        if (phones[phoneId].marker) {
          const originalIcon = phones[phoneId].marker.getIcon();
          // Flash the marker
          setTimeout(() => {
            if (phones[phoneId].marker) {
              phones[phoneId].marker.setIcon(L.divIcon({
                className: 'phone-marker-highlight',
                html: `<div style="width: 20px; height: 20px; background-color: #ffff00; border: 3px solid #ff0000; border-radius: 50%; animation: pulse 1s ease-in-out 3 alternate;"></div>`,
                iconSize: [20, 20],
                iconAnchor: [10, 10]
              }));
              
              // Restore original icon after animation
              setTimeout(() => {
                if (phones[phoneId].marker) {
                  phones[phoneId].marker.setIcon(originalIcon);
                }
              }, 3000);
            }
          }, 100);
        }
      } else {
        alert(`No location available for phone: ${phoneId}`);
      }
    }

    let navigationOriginPhone = null;

    async function setNavigationOrigin(phoneId) {
      await updateAllPhones(); // Ensure data is fresh
      if (phones[phoneId] && phones[phoneId].lat !== undefined && phones[phoneId].lng !== undefined) {
        navigationOriginPhone = phoneId;
        
        // Update the current location info in navigation panel
        const locationInfo = document.getElementById('currentLocationInfo');
        if (locationInfo) {
          locationInfo.style.backgroundColor = '#d4edda';
          locationInfo.innerHTML = `
            <h5 style="margin: 0 0 8px 0; color: #333;">Navigation Origin</h5>
            <div style="font-size: 12px; color: #666;">📱 ${phoneId}</div>
            <div style="font-size: 11px; color: #666;">Lat: ${phones[phoneId].lat.toFixed(6)}<br>Lng: ${phones[phoneId].lng.toFixed(6)}</div>
            <button id="centerOnOrigin" style="width: 100%; padding: 6px; margin-top: 8px; background: #28a745; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">Center on Origin</button>
            <button id="clearOrigin" style="width: 100%; padding: 4px; margin-top: 4px; background: #6c757d; color: white; border: none; border-radius: 4px; font-size: 11px; cursor: pointer;">Clear Origin</button>
          `;
          
          // Add event listeners for the new buttons
          document.getElementById('centerOnOrigin').addEventListener('click', () => {
            centerOnPhone(phoneId);
          });
          
          document.getElementById('clearOrigin').addEventListener('click', () => {
            clearNavigationOrigin();
          });
        }
        
        // Show navigation panel if hidden
        if (document.getElementById('navigationPanel').classList.contains('hidden')) {
          document.getElementById('navigationPanel').classList.remove('hidden');
        }
        
        alert(`Navigation origin set to phone: ${phoneId}. Click "Set Destination" to choose where to navigate to.`);
      } else {
        alert(`No location available for phone: ${phoneId}`);
      }
    }

    function clearNavigationOrigin() {
      navigationOriginPhone = null;
      updateLocationInfo(); // Reset to default location info
      
      // Restore original location info panel
      const locationInfo = document.getElementById('currentLocationInfo');
      if (locationInfo) {
        locationInfo.style.backgroundColor = '#e7f3ff';
        locationInfo.innerHTML = `
          <h5 style="margin: 0 0 8px 0; color: #333;">📍 Current Location</h5>
          <div id="locationCoords" style="font-size: 12px; color: #666;">Waiting for location...</div>
          <button id="centerOnLocation" style="width: 100%; padding: 6px; margin-top: 8px; background: #28a745; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">📌 Center on Me</button>
        `;
        
        // Re-add event listener for center button
        document.getElementById('centerOnLocation').addEventListener('click', function() {
          let userLocation = null;
          for (const phoneId in phones) {
            if (phones[phoneId] && phones[phoneId].lat !== undefined) {
              userLocation = { lat: phones[phoneId].lat, lng: phones[phoneId].lng };
              break;
            }
          }
          if (userLocation) {
            map.setView([userLocation.lat, userLocation.lng], 16);
          } else {
            alert('No location available to center on.');
          }
        });
      }
    }

    let phoneLabelsVisible = true;

    function togglePhoneLabels() {
      phoneLabelsVisible = !phoneLabelsVisible;
      Object.keys(phones).forEach(id => {
        if (phones[id].label) {
          phones[id].label.setOpacity(phoneLabelsVisible ? 1 : 0);
        }
      });
      document.getElementById("toggleLabels").innerText =
        phoneLabelsVisible ? "Hide Phone Labels" : "Show Phone Labels";
    }

    let directionArrowsVisible = true;

    function toggleDirectionArrows() {
      directionArrowsVisible = !directionArrowsVisible;
      Object.keys(phones).forEach(id => {
        if (phones[id].directionArrow) {
          phones[id].directionArrow.setOpacity(directionArrowsVisible ? 1 : 0);
        }
      });
      document.getElementById("toggleDirectionArrows").innerText =
        directionArrowsVisible ? "Hide Direction Arrows" : "Show Direction Arrows";
    }

    function clearAllPhones() {
      if (confirm("Are you sure you want to clear all tracked phones? This cannot be undone.")) {
        // Clear phones from map
        Object.keys(phones).forEach(id => {
          if (phones[id].marker) map.removeLayer(phones[id].marker);
          if (phones[id].label) map.removeLayer(phones[id].label);
          if (phones[id].directionArrow) map.removeLayer(phones[id].directionArrow);
        });
        
        // Clear phones object and reset follow mode
        Object.keys(phones).forEach(id => {
          delete phones[id];
        });
        followedPhone = null; // Reset follow mode
        
        // Send request to clear phones on server
        fetch("/save_phones", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({})
        })
        .then(res => res.json())
        .then(data => {
          console.log("Cleared all phones");
          updatePhoneList(); // Update the UI
        })
        .catch(err => console.error("Error clearing phones:", err));
      }
    }

    // Grid implementation with fixed global reference
    let gridVisible = false;
    let gridLayer = null;
    let gridLabels = [];
    const MIN_ZOOM_FOR_GRID = 14; // Only show grid at very zoomed in levels
    const MAX_ZOOM_FOR_GRID = 22; // No upper limit (or use max zoom level supported)
    const GRID_SIZE = 0.005; // Tiny grid size for close-up view
    const MAX_CELLS = 250; // Limited number of cells to prevent performance issues

    function createGrid() {
      // Remove existing grid if any
      if (gridLayer) {
        map.removeLayer(gridLayer);
        gridLabels.forEach(label => map.removeLayer(label));
        gridLabels = [];
      }
      
      // Only create grid if it should be visible
      if (!gridVisible) return;
      
      // Check if current zoom level is appropriate for the grid
      const currentZoom = map.getZoom();
      if (currentZoom < MIN_ZOOM_FOR_GRID) {
        document.getElementById("toggleGrid").innerText = "Show Grid (Zoom in more)";
        document.getElementById("toggleGrid").style.opacity = "0.7";
        console.log("Grid disabled: Not zoomed in enough (" + currentZoom + ")");
        return; // Don't create grid when not zoomed in enough
      }
      
      console.log("Creating grid with fixed GRID_SIZE: " + GRID_SIZE + " at zoom level: " + currentZoom);
      
      gridLayer = L.layerGroup().addTo(map);
      
      // Get map bounds
      const bounds = map.getBounds();
      const north = bounds.getNorth();
      const south = bounds.getSouth();
      const east = bounds.getEast();
      const west = bounds.getWest();
      
      // Calculate grid start positions (align with global grid)
      const startLng = Math.floor(west / GRID_SIZE) * GRID_SIZE;
      const startLat = Math.floor(south / GRID_SIZE) * GRID_SIZE;
      const endLng = Math.ceil(east / GRID_SIZE) * GRID_SIZE;
      const endLat = Math.ceil(north / GRID_SIZE) * GRID_SIZE;
      
      // Calculate cell count based on actual grid size
      const cellCount = Math.ceil((endLat - startLat) / GRID_SIZE) * Math.ceil((endLng - startLng) / GRID_SIZE);
      
      if (cellCount > MAX_CELLS) {
        console.log("Grid disabled: Too many cells (" + cellCount + " > " + MAX_CELLS + ")");
        map.removeLayer(gridLayer);
        document.getElementById("toggleGrid").innerText = "Show Grid (Zoom in more)";
        document.getElementById("toggleGrid").style.opacity = "0.7";
        return;
      }
      
      document.getElementById("toggleGrid").innerText = "Hide Grid";
      document.getElementById("toggleGrid").style.opacity = "1";
      
      // Create vertical grid lines
      for (let lng = startLng; lng <= endLng; lng += GRID_SIZE) {
        L.polyline([[south, lng], [north, lng]], {
          color: 'rgba(0,0,0,0.5)',
          weight: 1,
          dashArray: '2,2'
        }).addTo(gridLayer);
      }
      
      // Create horizontal grid lines
      for (let lat = startLat; lat <= endLat; lat += GRID_SIZE) {
        L.polyline([[lat, west], [lat, east]], {
          color: 'rgba(0,0,0,0.5)',
          weight: 1,
          dashArray: '2,2'
        }).addTo(gridLayer);
      }
      
      // Add grid labels with fixed global references
      for (let lat = startLat; lat <= endLat; lat += GRID_SIZE) {
        for (let lng = startLng; lng <= endLng; lng += GRID_SIZE) {
          // Calculate global reference values based on absolute position
          const letterIndex = Math.floor((lng + 180) / GRID_SIZE);
          const numberIndex = Math.floor((lat + 90) / GRID_SIZE);
          
          // Create consistent global grid references
          let letter = '';
          let letterValue = letterIndex;
          
          // Convert to multi-letter (AA, AB, etc.) for values over 26
          do {
            letter = String.fromCharCode(65 + (letterValue % 26)) + letter;
            letterValue = Math.floor(letterValue / 26) - 1;
          } while (letterValue >= 0);
          
          const gridRef = letter + numberIndex;
          
          const label = L.marker([lat + GRID_SIZE/2, lng + GRID_SIZE/2], {
            icon: L.divIcon({
              className: 'grid-label',
              html: gridRef,
              iconSize: [40, 20],
              iconAnchor: [20, 10]
            })
          }).addTo(gridLayer);
          gridLabels.push(label);
        }
      }
    }

    document.getElementById("toggleGrid").addEventListener('click', function() {
      gridVisible = !gridVisible;
      
      if (gridVisible) {
        createGrid();
        // When showing grid, add zoom end handler to recreate grid
        map.on('zoomend moveend', createGrid);
      } else {
        if (gridLayer) {
          map.removeLayer(gridLayer);
          gridLabels.forEach(label => map.removeLayer(label));
          gridLabels = [];
        }
        this.innerText = "Show Grid";
        this.style.opacity = "1";
        
        // Remove handler when grid is hidden
        map.off('zoomend moveend', createGrid);
      }
    });

    // POI pins implementation
    let pins = [];
    let pinsVisible = true;
    let placingPin = false;
    let pinsLayer = L.layerGroup().addTo(map);

    function createPinMarker(poi) {
      const marker = L.marker([poi.lat, poi.lng], {
        icon: L.divIcon({
          className: 'poi-marker',
          html: `<svg width="24" height="36" viewBox="0 0 24 36" fill="${poi.color}" 
                 xmlns="http://www.w3.org/2000/svg">
                 <path d="M12 0C5.4 0 0 5.4 0 12c0 7.2 12 24 12 24s12-16.8 12-24c0-6.6-5.4-12-12-12z" 
                 stroke="#000" stroke-width="1"/>
                 </svg>`,
          iconSize: [24, 36],
          iconAnchor: [12, 36],
          popupAnchor: [0, -36]
        })
      }).addTo(pinsLayer);

      const popupContent = `
        <div class="poi-title">${poi.title}</div>
        <div class="poi-description">${poi.description || ''}</div>
        <div style="margin-top: 8px; display: flex; gap: 4px;">
          <button class="navigate-to-poi-btn" style="flex: 1; background-color: #007bff; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;" 
            data-poi-lat="${poi.lat}" data-poi-lng="${poi.lng}">Navigate Here</button>
          <button class="delete-poi-btn" style="flex: 1; background-color: #ff4444; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;" 
            data-poi-id="${poi.id}">Delete</button>
        </div>
      `;
      
      marker.bindPopup(popupContent, {
        className: 'poi-popup',
        closeButton: true
      });
      
      // Store reference to original POI data
      marker.poi = poi;

      // Add event listeners for navigation and delete buttons after popup opens
      marker.on('popupopen', function() {
        const deleteBtn = document.querySelector('.delete-poi-btn[data-poi-id="'+poi.id+'"]');
        if (deleteBtn) {
          deleteBtn.addEventListener('click', function() {
            deletePOI(poi.id);
            map.closePopup();
          });
        }
        
        const navigateBtn = document.querySelector('.navigate-to-poi-btn[data-poi-lat="'+poi.lat+'"]');
        if (navigateBtn) {
          navigateBtn.addEventListener('click', function() {
            const lat = parseFloat(this.getAttribute('data-poi-lat'));
            const lng = parseFloat(this.getAttribute('data-poi-lng'));
            calculateRoute({ lat: lat, lng: lng });
            map.closePopup();
            
            // Show navigation panel if hidden
            if (document.getElementById('navigationPanel').classList.contains('hidden')) {
              document.getElementById('navigationPanel').classList.remove('hidden');
            }
          });
        }
      });

      return marker;
    }

    function savePOI(poi) {
      fetch("/save_poi", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(poi)
      })
      .then(res => res.json())
      .then(data => {
        console.log("Saved POI:", data);
        loadPOIs(); // Refresh to ensure consistency
      })
      .catch(err => console.error("Error saving POI:", err));
    }

    function loadPOIs() {
      fetch("/load_pois")
        .then(res => res.json())
        .then(data => {
          // Clear existing pins
          pinsLayer.clearLayers();
          pins = [];
          
          // Add all pins from server
          data.forEach(poi => {
            const marker = createPinMarker(poi);
            pins.push(marker);
          });
        })
        .catch(err => console.error("Error loading POIs:", err));
    }

    function deletePOI(poiId) {
      fetch("/delete_poi", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id: poiId })
      })
      .then(res => res.json())
      .then(data => {
        console.log("Deleted POI:", data);
        loadPOIs(); // Refresh pins after deletion
      })
      .catch(err => console.error("Error deleting POI:", err));
    }

    function clearAllPins() {
      if (confirm("Are you sure you want to delete all pins? This cannot be undone.")) {
        // Clear pins from map
        pinsLayer.clearLayers();
        pins = [];
        
        // Send request to clear all POIs on server
        fetch("/clear_pois", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({})
        })
        .then(res => res.json())
        .then(data => {
          console.log("Cleared all POIs");
        })
        .catch(err => console.error("Error clearing POIs:", err));
      }
    }

    // Pin placement mode
    document.getElementById("startPlacingPin").addEventListener('click', function() {
      placingPin = true;
      this.disabled = true;
      map.getContainer().style.cursor = 'crosshair';
      
      // One-time click handler for pin placement
      const clickHandler = function(e) {
        document.getElementById("pinDialog").style.display = "block";
        document.getElementById("startPlacingPin").disabled = false;
        
        document.getElementById("savePin").onclick = function() {
          const title = document.getElementById("pinTitle").value;
          if (!title) {
            alert("Please enter a title for the pin");
            return;
          }
          
          const poi = {
            id: Date.now().toString(), // Generate unique ID
            lat: e.latlng.lat,
            lng: e.latlng.lng,
            title: title,
            description: document.getElementById("pinDescription").value,
            color: document.getElementById("pinColor").value
          };
          
          savePOI(poi);
          
          // Reset UI
          document.getElementById("pinDialog").style.display = "none";
          document.getElementById("pinTitle").value = "";
          document.getElementById("pinDescription").value = "";
          map.getContainer().style.cursor = '';
        };
        
        document.getElementById("cancelPin").onclick = function() {
          document.getElementById("pinDialog").style.display = "none";
          map.getContainer().style.cursor = '';
        };
        
        placingPin = false;
        map.off('click', clickHandler);
      };
      
      map.once('click', clickHandler);
    });

    // Toggle pins visibility
    document.getElementById("togglePins").addEventListener('click', function() {
      pinsVisible = !pinsVisible;
      if (pinsVisible) {
        map.addLayer(pinsLayer);
        this.innerText = "Hide Pins";
      } else {
        map.removeLayer(pinsLayer);
        this.innerText = "Show Pins";
      }
    });

    document.getElementById("clearAllPins").addEventListener('click', clearAllPins);
    document.getElementById("clearAllPhones").addEventListener('click', clearAllPhones);

    // Navigation implementation
    let navigationActive = false;
    let navigationTarget = null;
    let currentRoute = null;
    let navigationMarker = null;
    let routeLayer = L.layerGroup().addTo(map);

    function startNavigation() {
      navigationActive = true;
      document.getElementById('setDestination').disabled = true;
      document.getElementById('setDestination').innerText = 'Click destination on map';
      map.getContainer().style.cursor = 'crosshair';
      
      const clickHandler = function(e) {
        navigationTarget = e.latlng;
        
        // Create destination marker
        if (navigationMarker) {
          map.removeLayer(navigationMarker);
        }
        
        navigationMarker = L.marker([e.latlng.lat, e.latlng.lng], {
          icon: L.divIcon({
            className: 'navigation-marker',
            html: `<div style="width: 20px; height: 20px; background-color: #ff4444; border-radius: 50%; border: 3px solid #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.3);"></div>`,
            iconSize: [20, 20],
            iconAnchor: [10, 10]
          })
        }).addTo(map);
        
        // Get user's current location and calculate route
        calculateRoute(e.latlng);
        
        document.getElementById('setDestination').disabled = false;
        document.getElementById('setDestination').innerText = 'Set Destination';
        navigationActive = false;
        map.getContainer().style.cursor = '';
        map.off('click', clickHandler);
      };
      
      map.once('click', clickHandler);
    }

    function calculateRoute(destination) {
      // Get starting location - prioritize selected origin phone, then any tracked phone, then map center
      let userLocation = null;
      let locationSource = '';
      
      // Check if a specific origin phone is selected
      if (navigationOriginPhone && phones[navigationOriginPhone] && phones[navigationOriginPhone].lat !== undefined) {
        userLocation = { lat: phones[navigationOriginPhone].lat, lng: phones[navigationOriginPhone].lng };
        locationSource = `📱 ${navigationOriginPhone}`;
      } else {
        // Look for any available phone location
        for (const phoneId in phones) {
          if (phones[phoneId] && phones[phoneId].lat !== undefined) {
            userLocation = { lat: phones[phoneId].lat, lng: phones[phoneId].lng };
            locationSource = `📱 ${phoneId} (auto-selected)`;
            break;
          }
        }
      }
      
      if (!userLocation) {
        // Fallback: use map center
        const center = map.getCenter();
        userLocation = { lat: center.lat, lng: center.lng };
        locationSource = 'Map center (no phones available)';
        alert('Using map center as starting point. For accurate navigation, set a navigation origin from a tracked phone.');
      }
      
      // Send route request to server with transportation mode
      const transportMode = document.getElementById('transportMode') ? document.getElementById('transportMode').value : 'walking';
      fetch('/get_route', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          start_lat: userLocation.lat,
          start_lng: userLocation.lng,
          end_lat: destination.lat,
          end_lng: destination.lng,
          mode: transportMode
        })
      })
      .then(response => response.json())
      .then(data => {
        displayRoute(data, userLocation, destination, locationSource);
      })
      .catch(error => {
        console.error('Error getting route:', error);
        // Fallback: draw straight line
        drawStraightLineRoute(userLocation, destination, locationSource);
      });
    }

    function displayRoute(routeData, start, end, locationSource) {
      // Clear existing route
      routeLayer.clearLayers();
      
      if (routeData.features && routeData.features.length > 0) {
        const feature = routeData.features[0];
        const coordinates = feature.geometry.coordinates;
        const properties = feature.properties || {};
        
        // Convert coordinates to Leaflet format [lat, lng]
        const latlngs = coordinates.map(coord => [coord[1], coord[0]]);
        
        // Create route line with different styles based on transport mode
        const transportMode = document.getElementById('transportMode') ? document.getElementById('transportMode').value : 'walking';
        let routeColor = '#007bff';
        let routeWeight = 5;
        
        switch(transportMode) {
          case 'walking':
            routeColor = '#28a745';
            routeWeight = 4;
            break;
          case 'driving':
            routeColor = '#dc3545';
            routeWeight = 6;
            break;
          case 'cycling':
            routeColor = '#fd7e14';
            routeWeight = 4;
            break;
        }
        
        // Create route line
        currentRoute = L.polyline(latlngs, {
          color: routeColor,
          weight: routeWeight,
          opacity: 0.8,
          className: 'route-line'
        }).addTo(routeLayer);
        
        // Calculate and display route information
        let distance = 0;
        let duration = 0;
        
        if (properties.distance) {
          distance = (properties.distance / 1000).toFixed(2);
        } else {
          // Calculate straight-line distance as fallback
          distance = (map.distance([start.lat, start.lng], [end.lat, end.lng]) / 1000).toFixed(2);
        }
        
        if (properties.duration) {
          duration = Math.round(properties.duration / 60);
        } else if (properties.time) {
          duration = Math.round(properties.time / 60000);
        }
        
        // Show navigation info
        document.getElementById('routeInfo').style.display = 'block';
        
        const transportEmoji = {
          walking: '🚶',
          driving: '🚗',
          cycling: '🚴'
        };
        
        let routeStatsHTML = `
          <div style="margin-bottom: 5px;">
            <strong>📍 From:</strong> ${locationSource || 'Current location'}
          </div>
          <div style="margin-bottom: 5px;">
            <strong>${transportEmoji[transportMode]} Distance:</strong> ${distance} km
          </div>
        `;
        
        if (duration > 0) {
          const hours = Math.floor(duration / 60);
          const mins = duration % 60;
          let durationText = '';
          if (hours > 0) {
            durationText = `${hours}h ${mins}m`;
          } else {
            durationText = `${mins}m`;
          }
          routeStatsHTML += `
            <div style="margin-bottom: 5px;">
              <strong>⏱️ Duration:</strong> ${durationText}
            </div>
          `;
        }
        
        document.getElementById('routeStats').innerHTML = routeStatsHTML;
        
        // Show service used
        const serviceUsed = routeData.service_used || properties.service || 'Unknown';
        let statusMessage = '';
        
        if (properties.fallback) {
          statusMessage = '⚠️ Showing straight-line route (routing service unavailable)';
          document.getElementById('routeStatus').style.color = '#ffc107';
        } else {
          statusMessage = `✅ Route provided by ${serviceUsed}`;
          document.getElementById('routeStatus').style.color = '#28a745';
        }
        
        document.getElementById('routeStatus').innerText = statusMessage;
        
        // Display turn-by-turn directions if available
        displayDirections(properties);
        
        // Fit map to show the route
        const routeBounds = currentRoute.getBounds();
        const startMarker = L.latLng(start.lat, start.lng);
        const endMarker = L.latLng(end.lat, end.lng);
        const bounds = L.latLngBounds([startMarker, endMarker]).extend(routeBounds);
        map.fitBounds(bounds, { padding: [20, 20] });
        
      } else {
        // Fallback: draw straight line
        drawStraightLineRoute(start, end, locationSource);
      }
    }

    function displayDirections(properties) {
      const directionsContainer = document.getElementById('directionsContainer');
      const directionsList = document.getElementById('directionsList');
      
      let directions = [];
      
      // Parse directions from different routing services
      if (properties.steps && Array.isArray(properties.steps)) {
        // OSRM or MapBox format
        directions = properties.steps.map((step, index) => {
          const instruction = step.maneuver?.instruction || step.instruction || `Step ${index + 1}`;
          const distance = step.distance ? `(${(step.distance / 1000).toFixed(2)} km)` : '';
          return { instruction, distance };
        });
      } else if (properties.instructions && Array.isArray(properties.instructions)) {
        // GraphHopper format
        directions = properties.instructions.map((instruction, index) => {
          const text = instruction.text || `Step ${index + 1}`;
          const distance = instruction.distance ? `(${(instruction.distance / 1000).toFixed(2)} km)` : '';
          return { instruction: text, distance };
        });
      }
      
      if (directions.length > 0) {
        directionsContainer.style.display = 'block';
        
        const directionsHTML = directions.map((dir, index) => `
          <div style="padding: 8px; border-bottom: 1px solid #eee; font-size: 12px;">
            <div style="font-weight: bold; color: #333; margin-bottom: 2px;">
              ${index + 1}. ${dir.instruction}
            </div>
            ${dir.distance ? `<div style="color: #666; font-size: 11px;">${dir.distance}</div>` : ''}
          </div>
        `).join('');
        
        directionsList.innerHTML = directionsHTML;
      } else {
        directionsContainer.style.display = 'none';
      }
    }

    function drawStraightLineRoute(start, end, locationSource) {
      routeLayer.clearLayers();
      
      currentRoute = L.polyline([[start.lat, start.lng], [end.lat, end.lng]], {
        color: '#ff4444',
        weight: 3,
        opacity: 0.6,
        dashArray: '10, 10',
        className: 'route-line'
      }).addTo(routeLayer);
      
      const distance = (map.distance([start.lat, start.lng], [end.lat, end.lng]) / 1000).toFixed(2);
      
      document.getElementById('routeInfo').style.display = 'block';
      let routeStatsHTML = `
        <div style="margin-bottom: 5px;">
          <strong>📍 From:</strong> ${locationSource || 'Current location'}
        </div>
        <div style="margin-bottom: 5px;">
          <strong>📏 Distance:</strong> ${distance} km (straight line)
        </div>
      `;
      document.getElementById('routeStats').innerHTML = routeStatsHTML;
      document.getElementById('routeStatus').innerText = 'Showing direct route - no turn-by-turn directions available';
    }

    function clearNavigation() {
      if (currentRoute) {
        routeLayer.clearLayers();
        currentRoute = null;
      }
      
      if (navigationMarker) {
        map.removeLayer(navigationMarker);
        navigationMarker = null;
      }
      
      navigationTarget = null;
      document.getElementById('routeInfo').style.display = 'none';
      document.getElementById('directionsContainer').style.display = 'none';
      
      // Reset navigation button if in progress
      if (navigationActive) {
        navigationActive = false;
        document.getElementById('setDestination').disabled = false;
        document.getElementById('setDestination').innerText = '📍 Set Destination';
        map.getContainer().style.cursor = '';
      }
    }

    // Update location info in navigation panel
    function updateLocationInfo() {
      let userLocation = null;
      let locationSource = 'Waiting for location...';
      
      // Check if a specific origin phone is selected
      if (navigationOriginPhone && phones[navigationOriginPhone] && phones[navigationOriginPhone].lat !== undefined) {
        userLocation = { lat: phones[navigationOriginPhone].lat, lng: phones[navigationOriginPhone].lng };
        locationSource = `
          <div style="font-weight: bold; color: #155724;">Origin: 📱 ${navigationOriginPhone}</div>
          <div>Lat: ${userLocation.lat.toFixed(6)}<br>Lng: ${userLocation.lng.toFixed(6)}</div>
        `;
      } else {
        // Look for any available phone location as a default
        for (const phoneId in phones) {
          if (phones[phoneId] && phones[phoneId].lat !== undefined) {
            userLocation = { lat: phones[phoneId].lat, lng: phones[phoneId].lng };
            locationSource = `
              <div style="font-style: italic;">Default: 📱 ${phoneId}</div>
              <div>Lat: ${userLocation.lat.toFixed(6)}<br>Lng: ${userLocation.lng.toFixed(6)}</div>
            `;
            break;
          }
        }
      }
      
      const locationCoordsDiv = document.getElementById('locationCoords');
      if (locationCoordsDiv) {
        locationCoordsDiv.innerHTML = locationSource;
      }
      
      const centerBtn = document.getElementById('centerOnLocation');
      if (centerBtn) {
        centerBtn.disabled = !userLocation;
      }
    }

    // Navigation event listeners
    document.getElementById('setDestination').addEventListener('click', startNavigation);
    document.getElementById('clearRoute').addEventListener('click', clearNavigation);
    
    document.getElementById('centerOnLocation').addEventListener('click', function() {
      let userLocation = null;
      
      // Look for the user's phone in the tracked phones
      for (const phoneId in phones) {
        if (phones[phoneId] && phones[phoneId].lat !== undefined) {
          userLocation = { lat: phones[phoneId].lat, lng: phones[phoneId].lng };
          break;
        }
      }
      
      if (userLocation) {
        map.setView([userLocation.lat, userLocation.lng], 16);
      } else {
        alert('No location available to center on.');
      }
    });

    // Distance measurement implementation
    let measuring = false;
    let measureStart = null;
    let measurements = [];
    let measurementsLayer = L.layerGroup().addTo(map);
    
    function startMeasuring() {
      measuring = true;
      measureStart = null;
      document.getElementById('startMeasuring').innerText = 'Cancel Measuring';
      document.getElementById('measurementInfo').style.display = 'block';
      map.getContainer().style.cursor = 'crosshair';
    }
    
    function stopMeasuring() {
      measuring = false;
      measureStart = null;
      document.getElementById('startMeasuring').innerText = 'Measure Distance';
      document.getElementById('measurementInfo').style.display = 'none';
      map.getContainer().style.cursor = '';
    }
    
    map.on('click', function(e) {
      if (!measuring) return;
      
      if (measureStart === null) {
        // First point clicked
        measureStart = e.latlng;
      } else {
        // Second point clicked, create the measurement line
        const measureEnd = e.latlng;
        
        // Calculate distance in meters and yards
       
        const distanceMeters = measureStart.distanceTo(measureEnd);
        const distanceYards = distanceMeters * 1.09361;
        
        // Create a measurement object
        const measurement = {
          id: Date.now().toString(),
          start: [measureStart.lat, measureStart.lng],
          end: [measureEnd.lat, measureEnd.lng],
          distanceMeters: Math.round(distanceMeters),
          distanceYards: Math.round(distanceYards)
        };
        
        // Add to local measurements and draw
        addMeasurementLine(measurement);
        
        // Save to server
        saveMeasurement(measurement);
        
        // Reset for next measurement
        measureStart = null;
      }
    });
    
    function addMeasurementLine(measurement) {
      const line = L.polyline([measurement.start, measurement.end], {
        color: '#FF6B00',
        weight: 3,
        dashArray: '5, 5',
        opacity: 0.7
      }).addTo(measurementsLayer);
      
      // Create label with distance
      const midpoint = L.latLng(
        (measurement.start[0] + measurement.end[0]) / 2,
        (measurement.start[1] + measurement.end[1]) / 2
      );
      
      const label = L.marker(midpoint, {
        icon: L.divIcon({
          className: 'distance-label',
          html: `<div style="background-color: white; padding: 3px 8px; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.3);">
                 <b>${measurement.distanceMeters}m</b> (${measurement.distanceYards}yds)
                 </div>`,
          iconSize: [100, 40],
          iconAnchor: [50, 20]
        })
      }).addTo(measurementsLayer);
      
      // Store reference to map objects
      measurement.line = line;
      measurement.label = label;
      measurements.push(measurement);
    }
    
    function saveMeasurement(measurement) {
      // Create a clean copy without Leaflet objects
      const cleanMeasurement = {
        id: measurement.id,
        start: measurement.start,
        end: measurement.end,
        distanceMeters: measurement.distanceMeters,
        distanceYards: measurement.distanceYards
      };
      
      fetch("/save_measurement", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(cleanMeasurement)
      })
      .then(res => res.json())
      .then(data => {
        console.log("Saved measurement:", data);
      })
      .catch(err => console.error("Error saving measurement:", err));
    }
    
    function loadMeasurements() {
      fetch("/load_measurements")
        .then(res => res.json())
        .then(data => {
          // Clear existing measurements
          measurementsLayer.clearLayers();
          measurements = [];
          
          // Add all measurements from server
          data.forEach(measurement => {
            addMeasurementLine(measurement);
          });
        })
        .catch(err => console.error("Error loading measurements:", err));
    }
    
    function clearAllMeasurements() {
      if (confirm("Are you sure you want to clear all distance measurements? This cannot be undone.")) {
        measurementsLayer.clearLayers();
        measurements = [];
        
        fetch("/clear_measurements", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({})
        })
        .then(res => res.json())
        .then(data => {
          console.log("Cleared all measurements");
        })
        .catch(err => console.error("Error clearing measurements:", err));
      }
    }
    
    document.getElementById("startMeasuring").addEventListener('click', function() {
      if (measuring) {
        stopMeasuring();
      } else {
        startMeasuring();
      }
    });
    
    document.getElementById("clearMeasurements").addEventListener('click', clearAllMeasurements);

    // Notes functionality
    let notes = [];

    function loadNotes() {
      fetch("/load_notes")
        .then(res => res.json())
        .then(data => {
          notes = data;
          displayNotes();
        })
        .catch(err => console.error("Error loading notes:", err));
    }

    function displayNotes() {
      const notesList = document.getElementById('notesList');
      const noNotesMessage = document.getElementById('noNotesMessage');
      
      // Clear existing notes
      notesList.innerHTML = '';
      
      if (notes.length === 0) {
        notesList.appendChild(noNotesMessage);
      } else {
        // Sort notes by timestamp (newest first)
        const sortedNotes = [...notes].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        sortedNotes.forEach(note => {
          const noteElement = createNoteElement(note);
          notesList.appendChild(noteElement);
        });
      }
    }

    function createNoteElement(note) {
      const noteDiv = document.createElement('div');
      noteDiv.className = 'note-item';
      
      const headerDiv = document.createElement('div');
      headerDiv.className = 'note-header';
      
      const timestampSpan = document.createElement('span');
      timestampSpan.className = 'note-timestamp';
      timestampSpan.textContent = formatTimestamp(note.timestamp);
      
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'note-delete-btn';
      deleteBtn.textContent = '×';
      deleteBtn.title = 'Delete note';
      deleteBtn.onclick = function() {
        if (confirm('Delete this note?')) {
          deleteNote(note.id);
        }
      };
      
      headerDiv.appendChild(timestampSpan);
      headerDiv.appendChild(deleteBtn);
      
      const contentDiv = document.createElement('div');
      contentDiv.className = 'note-content';
      contentDiv.textContent = note.content;
      
      noteDiv.appendChild(headerDiv);
      noteDiv.appendChild(contentDiv);
      
      return noteDiv;
    }

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMins / 60);
      const diffDays = Math.floor(diffHours / 24);
      
      if (diffMins < 1) {
        return 'Just now';
      } else if (diffMins < 60) {
        return `${diffMins}m ago`;
      } else if (diffHours < 24) {
        return `${diffHours}h ago`;
      } else if (diffDays < 7) {
        return `${diffDays}d ago`;
      } else {
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
      }
    }

    function showAddNoteDialog() {
      const dialog = document.getElementById('noteDialog');
      const textarea = document.getElementById('noteContent');
      
      textarea.value = '';
      dialog.style.display = 'block';
      textarea.focus();
    }

    function hideAddNoteDialog() {
      const dialog = document.getElementById('noteDialog');
      dialog.style.display = 'none';
    }

    function saveNote() {
      const content = document.getElementById('noteContent').value.trim();
      
      if (!content) {
        alert('Please enter a note before posting.');
        return;
      }
      
      const note = {
        id: Date.now().toString(),
        content: content,
        timestamp: new Date().toISOString()
      };
      
      fetch("/save_note", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(note)
      })
      .then(res => res.json())
      .then(data => {
        console.log("Note saved:", data);
        loadNotes(); // Refresh notes list
        hideAddNoteDialog();
      })
      .catch(err => {
        console.error("Error saving note:", err);
        alert('Failed to save note. Please try again.');
      });
    }

    function deleteNote(noteId) {
      fetch("/delete_note", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id: noteId })
      })
      .then(res => res.json())
      .then(data => {
        console.log("Note deleted:", data);
        loadNotes(); // Refresh notes list
      })
      .catch(err => {
        console.error("Error deleting note:", err);
        alert('Failed to delete note. Please try again.');
      });
    }

    // Notes event listeners
    document.getElementById('addNote').addEventListener('click', showAddNoteDialog);
    document.getElementById('refreshNotes').addEventListener('click', loadNotes);
    document.getElementById('saveNoteBtn').addEventListener('click', saveNote);
    document.getElementById('cancelNoteBtn').addEventListener('click', hideAddNoteDialog);
    
    // Allow Enter+Shift for new lines, but Enter alone posts the note
    document.getElementById('noteContent').addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        saveNote();
      }
    });
    
    // Close dialog when clicking outside
    document.getElementById('noteDialog').addEventListener('click', function(e) {
      if (e.target === this) {
        hideAddNoteDialog();
      }
    });

    loadDrawings();
    updateAllPhones();
    loadPOIs();
    loadMeasurements();
    loadNotes();
    updateTrackedDeviceSelect(); // Initial population of weather device selector
    
    setInterval(loadDrawings, 10000);  // Reduced frequency to prevent conflicts
    setInterval(updateAllPhones, 5000);
    setInterval(loadPOIs, 5000);
    setInterval(loadMeasurements, 5000);
    setInterval(loadNotes, 5000);
    setInterval(updateLocationInfo, 5000); // Update location info in navigation panel

    // Toggle functionality for split buttons
    document.getElementById('toggleMenu').addEventListener('click', () => {
      document.getElementById('controls').classList.toggle('hidden');
    });
    
    document.getElementById('toggleNotes').addEventListener('click', () => {
      document.getElementById('notesPanel').classList.toggle('hidden');
    });

    document.getElementById('toggleNavigation').addEventListener('click', () => {
      document.getElementById('navigationPanel').classList.toggle('hidden');
    });

    document.getElementById('toggleWeather').addEventListener('click', () => {
      document.getElementById('weatherPanel').classList.toggle('hidden');
    });

    document.getElementById('toggleRadio').addEventListener('click', () => {
      document.getElementById('radioPanel').classList.toggle('hidden');
    });
    
    // Share location functionality
    document.getElementById('shareLocationBtn').addEventListener('click', () => {
      if (!navigator.geolocation) {
        alert("Geolocation is not supported by your browser.");
        return;
      }

      const phoneId = prompt("Please enter your name or a unique ID for your location marker:", "web-client");
      if (!phoneId) {
        return; // User cancelled the prompt
      }

      function success(position) {
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;
        const heading = position.coords.heading;
        const alt = position.coords.altitude;

        console.log(`Sharing location for ${phoneId}: ${lat}, ${lng}`);

        fetch("/update_location", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ id: phoneId, lat, lng, heading, alt })
        })
        .then(response => response.json())
        .then(data => {
          if (data.status === 'updated') {
            alert('Location shared successfully!');
            updateAllPhones(); // Refresh the map to show the new location
          } else {
            alert('Error sharing location: ' + (data.message || 'Unknown error'));
          }
        })
        .catch(error => {
          console.error("Error sharing location:", error);
          alert("An error occurred while sharing your location.");
        });
      }

      function error() {
        alert("Unable to retrieve your location. Please ensure you have enabled location services for your browser.");
      }

      navigator.geolocation.getCurrentPosition(success, error, {
        enableHighAccuracy: true
      });
    });

    // Weather functionality
    const WEATHER_API_KEY = 'e5a22a0e01663d82908ab1cf69e7c73d'; // OpenWeatherMap API key
    
    function getWeatherByZip() {
      const zipCode = document.getElementById('zipCodeInput').value.trim();
      if (!zipCode) {
        showWeatherError('Please enter a ZIP code');
        return;
      }
      
      // Extract just the numbers from ZIP code
      const cleanZip = zipCode.replace(/[^\d]/g, '');
      if (cleanZip.length !== 5) {
        showWeatherError('Please enter a valid 5-digit ZIP code');
        return;
      }
      
      // Try both with and without country code for better compatibility
      fetchWeatherData(`zip=${cleanZip},US`);
    }
    
    function getWeatherByGPS() {
      // Try to get location from tracked phones first
      let userLocation = null;
      
      // Check if there's a followed phone
      if (followedPhone && phones[followedPhone] && phones[followedPhone].lat !== undefined) {
        userLocation = { lat: phones[followedPhone].lat, lng: phones[followedPhone].lng };
      } else {
        // Look for any available phone location
        for (const phoneId in phones) {
          if (phones[phoneId] && phones[phoneId].lat !== undefined) {
            userLocation = { lat: phones[phoneId].lat, lng: phones[phoneId].lng };
            break;
          }
        }
      }
      
      if (userLocation) {
        fetchWeatherData(`lat=${userLocation.lat}&lon=${userLocation.lng}`);
      } else {
        // Fallback to browser geolocation
        if (navigator.geolocation) {
          // Show loading state
          document.getElementById('weatherLocation').textContent = 'Getting your location...';
          document.getElementById('weatherDisplay').style.display = 'block';
          
          navigator.geolocation.getCurrentPosition(
            (position) => {
              const lat = position.coords.latitude;
              const lng = position.coords.longitude;
              fetchWeatherData(`lat=${lat}&lon=${lng}`);
            },
            (error) => {
              let message = 'Unable to get your location.';
              
              switch (error.code) {
                case error.PERMISSION_DENIED:
                  message = 'Location access denied. Please enable location services or use ZIP code.';
                  break;
                case error.POSITION_UNAVAILABLE:
                  message = 'Location information is unavailable. Please try ZIP code.';
                  break;
                case error.TIMEOUT:
                  message = 'Location request timed out. Please try ZIP code.';
                  break;
              }
              
              document.getElementById('weatherDisplay').style.display = 'none';
              showWeatherError(message);
            },
            {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 300000 // 5 minutes
            }
          );
        } else {
          showWeatherError('Geolocation not supported by this browser. Please use ZIP code instead.');
        }
      }
    }
    
    function getWeatherByDevice() {
      const deviceSelect = document.getElementById('trackedDeviceSelect');
      const selectedDeviceId = deviceSelect.value;
      
      if (!selectedDeviceId) {
        showWeatherError('Please select a tracked device first.');
        return;
      }
      
      if (phones[selectedDeviceId] && phones[selectedDeviceId].lat !== undefined && phones[selectedDeviceId].lng !== undefined) {
        const lat = phones[selectedDeviceId].lat;
        const lng = phones[selectedDeviceId].lng;
        
        // Show loading state with device name
        document.getElementById('weatherLocation').textContent = `Getting weather for ${selectedDeviceId}...`;
        document.getElementById('weatherDisplay').style.display = 'block';
        
        fetchWeatherData(`lat=${lat}&lon=${lng}`);
      } else {
        showWeatherError(`No location data available for device "${selectedDeviceId}".`);
      }
    }
    
    function updateTrackedDeviceSelect() {
      const deviceSelect = document.getElementById('trackedDeviceSelect');
      const currentValue = deviceSelect.value;
      
      // Clear existing options except the first one
      deviceSelect.innerHTML = '<option value="">Select a tracked device...</option>';
      
      // Add options for each tracked phone
      const phoneIds = Object.keys(phones);
      if (phoneIds.length > 0) {
        phoneIds.forEach(phoneId => {
          if (phones[phoneId] && phones[phoneId].lat !== undefined && phones[phoneId].lng !== undefined) {
            const option = document.createElement('option');
            option.value = phoneId;
            option.textContent = `📱 ${phoneId}`;
            deviceSelect.appendChild(option);
          }
        });
        
        // Restore previous selection if it still exists
        if (currentValue && phones[currentValue]) {
          deviceSelect.value = currentValue;
        }
        
        // Enable the button
        document.getElementById('getWeatherByDevice').disabled = false;
      } else {
        // No devices available
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No tracked devices available';
        option.disabled = true;
        deviceSelect.appendChild(option);
        
        // Disable the button
        document.getElementById('getWeatherByDevice').disabled = true;
      }
    }
    
    function fetchWeatherData(locationQuery) {
      showWeatherError(''); // Clear any previous errors
      document.getElementById('weatherDisplay').style.display = 'none';
      
      // Show loading state
      document.getElementById('weatherLocation').textContent = 'Loading...';
      document.getElementById('weatherDisplay').style.display = 'block';
      
      // Real OpenWeatherMap API call
      const url = `https://api.openweathermap.org/data/2.5/weather?${locationQuery}&appid=${WEATHER_API_KEY}&units=imperial`;
      
      fetch(url)
        .then(response => {
          if (!response.ok) {
            // Handle specific API error codes
            let errorMessage = 'Unable to fetch weather data.';
            switch (response.status) {
              case 401:
                errorMessage = 'Weather API authentication failed.';
                break;
              case 404:
                errorMessage = 'Location not found. Please check your ZIP code or try a different location.';
                break;
              case 429:
                errorMessage = 'Too many requests. Please wait a moment and try again.';
                break;
              case 500:
              case 502:
              case 503:
                errorMessage = 'Weather service temporarily unavailable. Please try again later.';
                break;
              default:
                errorMessage = `Weather service error (${response.status}). Please try again.`;
            }
            throw new Error(errorMessage);
          }
          return response.json();
        })
        .then(data => {
          displayWeatherData(data);
        })
        .catch(error => {
          console.error('Weather fetch error:', error);
          
          // Check if it's a network error or specific API error
          if (error.message.includes('fetch')) {
            showWeatherError('Network error. Please check your internet connection and try again.');
          } else if (error.message.includes('authentication') || error.message.includes('API')) {
            showWeatherError(error.message);
          } else if (error.message.includes('not found')) {
            showWeatherError(error.message);
          } else {
            // Try fallback with mock data if API fails
            console.log('API failed, falling back to mock data for demonstration');
            const mockWeatherData = {
              name: locationQuery.includes('zip=') ? `ZIP ${locationQuery.split('=')[1].split(',')[0]}` : 'Current Location',
              main: {
                temp: Math.round(Math.random() * 40 + 40), // Random temp between 40-80°F
                feels_like: Math.round(Math.random() * 40 + 40),
                humidity: Math.round(Math.random() * 50 + 30),
                pressure: Math.round(Math.random() * 100 + 1000)
              },
              weather: [
                {
                  main: ['Clear', 'Clouds', 'Rain', 'Snow'][Math.floor(Math.random() * 4)],
                  description: 'partly cloudy',
                  icon: '02d'
                }
              ],
              wind: {
                speed: Math.round(Math.random() * 20 + 5),
                deg: Math.round(Math.random() * 360)
              },
              visibility: Math.round(Math.random() * 5000 + 5000),
              sys: {
                sunrise: Date.now() / 1000 - 6 * 3600, // 6 hours ago
                sunset: Date.now() / 1000 + 6 * 3600   // 6 hours from now
              },
              dt: Date.now() / 1000
            };
            displayWeatherData(mockWeatherData);
            showWeatherError('Using demo data - Weather API unavailable. Information shown is simulated for demonstration.');
          }
        });
    }
    
    function displayWeatherData(data) {
      // Determine if this weather is for a specific device
      const deviceSelect = document.getElementById('trackedDeviceSelect');
      const selectedDevice = deviceSelect.value;
      
      // Location - show device info if weather was requested for a specific device
      let locationText = data.name;
      if (selectedDevice && phones[selectedDevice]) {
        locationText = `${data.name} (📱 ${selectedDevice})`;
      }
      document.getElementById('weatherLocation').textContent = locationText;
      
      // Temperature and description
      document.getElementById('weatherTemp').textContent = `${Math.round(data.main.temp)}°F`;
      document.getElementById('weatherDescription').textContent = data.weather[0].description;
      
      // Weather icon using OpenWeatherMap icon URL
      const iconCode = data.weather[0].icon;
      const iconImg = document.createElement('img');
      iconImg.src = `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
      iconImg.alt = data.weather[0].description;
      iconImg.style.width = '32px';
      iconImg.style.height = '32px';
      const iconDiv = document.getElementById('weatherIcon');
      iconDiv.innerHTML = '';
      iconDiv.appendChild(iconImg);
      
      // Details
      document.getElementById('weatherFeelsLike').textContent = `${Math.round(data.main.feels_like)}°F`;
      document.getElementById('weatherHumidity').textContent = `${data.main.humidity}%`;
      
      // Wind direction and speed
      const windDirection = getWindDirection(data.wind.deg || 0);
      document.getElementById('weatherWind').textContent = `${windDirection} ${Math.round(data.wind.speed || 0)} mph`;
      
      document.getElementById('weatherPressure').textContent = `${Math.round(data.main.pressure * 0.02953)} inHg`;
      document.getElementById('weatherVisibility').textContent = data.visibility ? `${Math.round(data.visibility * 0.000621371)} mi` : 'N/A';
      document.getElementById('weatherUV').textContent = 'N/A'; // UV index requires separate API call
      
      // Sunrise/Sunset
      const sunrise = new Date(data.sys.sunrise * 1000);
      const sunset = new Date(data.sys.sunset * 1000);
      document.getElementById('weatherSunrise').textContent = sunrise.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      document.getElementById('weatherSunset').textContent = sunset.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      
      // Last update
      const lastUpdate = new Date(data.dt * 1000);
      document.getElementById('weatherLastUpdate').textContent = `Updated: ${lastUpdate.toLocaleTimeString()}`;
      
      // Show weather display
      document.getElementById('weatherDisplay').style.display = 'block';
    }
    
    function getWindDirection(degrees) {
      const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
      const index = Math.round(degrees / 22.5) % 16;
      return directions[index];
    }
    
    function showWeatherError(message) {
      const errorDiv = document.getElementById('weatherError');
      if (message) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
        
        // Auto-hide non-critical errors after 8 seconds
        if (!message.includes('demo data') && !message.includes('simulated')) {
          setTimeout(() => {
            if (errorDiv.textContent === message) {
              errorDiv.style.display = 'none';
            }
          }, 8000);
        }
      } else {
        errorDiv.style.display = 'none';
      }
    }
    
    // Weather event listeners
    document.getElementById('getWeatherByZip').addEventListener('click', getWeatherByZip);
    document.getElementById('getWeatherByGPS').addEventListener('click', getWeatherByGPS);
    document.getElementById('getWeatherByDevice').addEventListener('click', getWeatherByDevice);
    
    // Allow Enter key in ZIP code input
    document.getElementById('zipCodeInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        getWeatherByZip();
      }
    });

    // ===== RADIO FREQUENCIES FUNCTIONALITY =====
    
    // Create the radio channels grid
    function createRadioChannels() {
      const radioGrid = document.getElementById('radioGrid');
      radioGrid.innerHTML = '';
      
      for (let i = 1; i <= 40; i++) {
        const channelDiv = document.createElement('div');
        channelDiv.className = 'radio-channel';
        
        const label = document.createElement('label');
        label.textContent = `CH${i}:`;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.id = `channel${i}`;
        input.placeholder = 'Frequency';
        input.maxLength = 20;
        
        channelDiv.appendChild(label);
        channelDiv.appendChild(input);
        radioGrid.appendChild(channelDiv);
      }
    }
    
    // Load radio frequencies from server
    function loadRadioFrequencies() {
      fetch('/load_radio_frequencies')
        .then(response => response.json())
        .then(frequencies => {
          for (let i = 1; i <= 40; i++) {
            const input = document.getElementById(`channel${i}`);
            if (input && frequencies[i.toString()]) {
              input.value = frequencies[i.toString()];
            }
          }
        })
        .catch(error => {
          console.error('Error loading radio frequencies:', error);
        });
    }
    
    // Save radio frequencies to server
    function saveRadioFrequencies() {
      const frequencies = {};
      
      for (let i = 1; i <= 40; i++) {
        const input = document.getElementById(`channel${i}`);
        if (input) {
          frequencies[i.toString()] = input.value.trim();
        }
      }
      
      fetch('/save_radio_frequencies', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(frequencies)
      })
      .then(response => response.json())
      .then(data => {
        if (data.status === 'saved') {
          // Brief visual feedback
          const saveBtn = document.getElementById('saveRadio');
          const originalText = saveBtn.textContent;
          saveBtn.textContent = 'Saved!';
          saveBtn.style.background = '#28a745';
          setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.style.background = '';
          }, 1000);
        }
      })
      .catch(error => {
        console.error('Error saving radio frequencies:', error);
        alert('Error saving radio frequencies');
      });
    }
    
    // Clear all radio frequencies
    function clearRadioFrequencies() {
      if (confirm('Are you sure you want to clear all radio frequencies?')) {
        fetch('/clear_radio_frequencies', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          }
        })
        .then(response => response.json())
        .then(data => {
          if (data.status === 'cleared') {
            for (let i = 1; i <= 40; i++) {
              const input = document.getElementById(`channel${i}`);
              if (input) {
                input.value = '';
              }
            }
          }
        })
        .catch(error => {
          console.error('Error clearing radio frequencies:', error);
          alert('Error clearing radio frequencies');
        });
      }
    }
    
    // Auto-save functionality for radio frequencies
    function setupRadioAutoSave() {
      const radioGrid = document.getElementById('radioGrid');
      if (radioGrid) {
        radioGrid.addEventListener('input', function(e) {
          if (e.target.tagName === 'INPUT') {
            // Auto-save after a brief delay when user stops typing
            clearTimeout(window.radioSaveTimeout);
            window.radioSaveTimeout = setTimeout(() => {
              saveRadioFrequencies();
            }, 2000); // 2 second delay
          }
        });
      }
    }
    
    // Initialize radio frequencies
    createRadioChannels();
    loadRadioFrequencies();
    setupRadioAutoSave();
    
    // Radio control event listeners
    document.getElementById('saveRadio').addEventListener('click', saveRadioFrequencies);
    document.getElementById('clearRadio').addEventListener('click', clearRadioFrequencies);
    
    } // End of initializeMap function

  // Compass toggle functionality
  let compassVisible = true;
  const compassElem = document.getElementById('compass');
  const toggleCompassBtn = document.getElementById('toggleCompass');
  if (toggleCompassBtn && compassElem) {
    toggleCompassBtn.addEventListener('click', function() {
      compassVisible = !compassVisible;
      compassElem.style.display = compassVisible ? 'flex' : 'none';
      this.innerText = compassVisible ? 'Compass' : 'Compass';
    });
  }
  </script>
</body>
</html>
